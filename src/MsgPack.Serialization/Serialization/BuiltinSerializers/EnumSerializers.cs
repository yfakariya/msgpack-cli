// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;

namespace MsgPack.Serialization
{
	internal partial class SerializerFactory
	{
		private static Type GetEnumSerializerGenericTypeDefinition(Type underlyingType)
		{
			if (underlyingType == typeof(System.Int32))
			{
				return typeof(BuiltinSerializers.Int32EnumSerializer<>);
			}

			if (underlyingType == typeof(System.Int64))
			{
				return typeof(BuiltinSerializers.Int64EnumSerializer<>);
			}

			if (underlyingType == typeof(System.UInt32))
			{
				return typeof(BuiltinSerializers.UInt32EnumSerializer<>);
			}

			if (underlyingType == typeof(System.UInt64))
			{
				return typeof(BuiltinSerializers.UInt64EnumSerializer<>);
			}

			if (underlyingType == typeof(System.Byte))
			{
				return typeof(BuiltinSerializers.ByteEnumSerializer<>);
			}

			if (underlyingType == typeof(System.Int16))
			{
				return typeof(BuiltinSerializers.Int16EnumSerializer<>);
			}

			if (underlyingType == typeof(System.SByte))
			{
				return typeof(BuiltinSerializers.SByteEnumSerializer<>);
			}

			if (underlyingType == typeof(System.UInt16))
			{
				return typeof(BuiltinSerializers.UInt16EnumSerializer<>);
			}

			if (underlyingType == typeof(System.Boolean))
			{
				return typeof(BuiltinSerializers.BooleanEnumSerializer<>);
			}

			if (underlyingType == typeof(System.Char))
			{
				return typeof(BuiltinSerializers.CharEnumSerializer<>);
			}

			if (underlyingType == typeof(System.Single))
			{
				return typeof(BuiltinSerializers.SingleEnumSerializer<>);
			}

			if (underlyingType == typeof(System.Double))
			{
				return typeof(BuiltinSerializers.DoubleEnumSerializer<>);
			}

			Throw.UnsupportedEnumUnderlyingType(underlyingType);
			return null!; // Never reaches
		}
	}

}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class Int32EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public Int32EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeInt32(*(Int32*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Int32));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Int32));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < Int32.MinValue || value > Int32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(Int32), value);
			}
			var underlyingValue = unchecked((Int32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > (UInt64)Int32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Int32), value);
			}
			var underlyingValue = unchecked((Int32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < Int32.MinValue || value > Int32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Int32), value);
			}
			var underlyingValue = unchecked((Int32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < Int32.MinValue || value > Int32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Int32), value);
			}
			var underlyingValue = unchecked((Int32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class Int64EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public Int64EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeInt64(*(Int64*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Int64));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Int64));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			var underlyingValue = unchecked((Int64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > (UInt64)Int64.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Int64), value);
			}
			var underlyingValue = unchecked((Int64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < Int64.MinValue || value > Int64.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Int64), value);
			}
			var underlyingValue = unchecked((Int64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < Int64.MinValue || value > Int64.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Int64), value);
			}
			var underlyingValue = unchecked((Int64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class UInt32EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public UInt32EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeUInt32(*(UInt32*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(UInt32));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(UInt32));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			if (value < 0)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(UInt32), value);
			}
			var underlyingValue = unchecked((UInt32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < 0 || value > UInt32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(UInt32), value);
			}
			var underlyingValue = unchecked((UInt32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > UInt32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(UInt32), value);
			}
			var underlyingValue = unchecked((UInt32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < 0 || value > UInt32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(UInt32), value);
			}
			var underlyingValue = unchecked((UInt32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < 0 || value > UInt32.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(UInt32), value);
			}
			var underlyingValue = unchecked((UInt32)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class UInt64EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public UInt64EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeUInt64(*(UInt64*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(UInt64));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(UInt64));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			var underlyingValue = unchecked((UInt64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < 0)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(UInt64), value);
			}
			var underlyingValue = unchecked((UInt64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < 0 || value > UInt64.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(UInt64), value);
			}
			var underlyingValue = unchecked((UInt64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < 0 || value > UInt64.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(UInt64), value);
			}
			var underlyingValue = unchecked((UInt64)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class ByteEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public ByteEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeUInt32(*(Byte*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Byte));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Byte));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			if (value < 0 || value > Byte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(Byte), value);
			}
			var underlyingValue = unchecked((Byte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < 0 || value > Byte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(Byte), value);
			}
			var underlyingValue = unchecked((Byte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > Byte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Byte), value);
			}
			var underlyingValue = unchecked((Byte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < 0 || value > Byte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Byte), value);
			}
			var underlyingValue = unchecked((Byte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < 0 || value > Byte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Byte), value);
			}
			var underlyingValue = unchecked((Byte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class Int16EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public Int16EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeInt32(*(Int16*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Int16));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Int16));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			if (value < Int16.MinValue || value > Int16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(Int16), value);
			}
			var underlyingValue = unchecked((Int16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < Int16.MinValue || value > Int16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(Int16), value);
			}
			var underlyingValue = unchecked((Int16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > (UInt64)Int16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Int16), value);
			}
			var underlyingValue = unchecked((Int16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < Int16.MinValue || value > Int16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Int16), value);
			}
			var underlyingValue = unchecked((Int16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < Int16.MinValue || value > Int16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Int16), value);
			}
			var underlyingValue = unchecked((Int16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class SByteEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public SByteEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeInt32(*(SByte*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(SByte));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(SByte));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			if (value < SByte.MinValue || value > SByte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(SByte), value);
			}
			var underlyingValue = unchecked((SByte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < SByte.MinValue || value > SByte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(SByte), value);
			}
			var underlyingValue = unchecked((SByte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > (UInt64)SByte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(SByte), value);
			}
			var underlyingValue = unchecked((SByte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < SByte.MinValue || value > SByte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(SByte), value);
			}
			var underlyingValue = unchecked((SByte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < SByte.MinValue || value > SByte.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(SByte), value);
			}
			var underlyingValue = unchecked((SByte)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class UInt16EnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public UInt16EnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeUInt32(*(UInt16*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(UInt16));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(UInt16));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			if (value < 0 || value > UInt16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(UInt16), value);
			}
			var underlyingValue = unchecked((UInt16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			if (value < 0 || value > UInt16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(UInt16), value);
			}
			var underlyingValue = unchecked((UInt16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			if (value > UInt16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(UInt16), value);
			}
			var underlyingValue = unchecked((UInt16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			if (value < 0 || value > UInt16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Single), typeof(T), typeof(UInt16), value);
			}
			var underlyingValue = unchecked((UInt16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < 0 || value > UInt16.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(UInt16), value);
			}
			var underlyingValue = unchecked((UInt16)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class BooleanEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public BooleanEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeBoolean(*(Boolean*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt64(long value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}

		protected sealed override T FromUInt64(ulong value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}

		protected sealed override T FromSingle(float value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}

		protected sealed override T FromDouble(double value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Boolean));
			return default!; // Never reaches.
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class CharEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public CharEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				var c = *(char*)(&value);
				Span<char> input = stackalloc char[1];
				input[0] = c;
				context.Encoder.EncodeString(input, sink, context.StringEncoding);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt32(int value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Int32), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt64(long value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Int64), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}

		protected sealed override T FromUInt64(ulong value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(UInt64), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}

		protected sealed override T FromSingle(float value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Single), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}

		protected sealed override T FromDouble(double value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Char));
			return default!; // Never reaches.
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class SingleEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public SingleEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeSingle(*(Single*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Single));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Single));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			var underlyingValue = unchecked((Single)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			var underlyingValue = unchecked((Single)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			var underlyingValue = unchecked((Single)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			if (value < Single.MinValue || value > Single.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(Double), typeof(T), typeof(Single), value);
			}
			var underlyingValue = unchecked((Single)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class DoubleEnumSerializer<T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public DoubleEnumSerializer(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.EncodeDouble(*(Double*)(&value), sink);
			}
		}

		protected sealed override T FromBoolean(bool value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Boolean), typeof(T), typeof(Double));
			return default!; // Never reaches.
		}

		protected sealed override T FromChar(char value)
		{
			Throw.IncompatibleEnumUnderlyingValue(typeof(Char), typeof(T), typeof(Double));
			return default!; // Never reaches.
		}

		protected sealed override T FromInt32(int value)
		{
			var underlyingValue = unchecked((Double)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromInt64(long value)
		{
			var underlyingValue = unchecked((Double)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromUInt64(ulong value)
		{
			var underlyingValue = unchecked((Double)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromSingle(float value)
		{
			var underlyingValue = unchecked((Double)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}

		protected sealed override T FromDouble(double value)
		{
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
		}
	}

}
