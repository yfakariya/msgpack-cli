<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
// According to ECMA 335 II.14.3, following types can be enum's underlying type:
// * Boolean
// * Char
// * SByte
// * Int16
// * Int32
// * Int64
// * IntPtr (nint)
// * Byte
// * UInt16
// * UInt32
// * UInt64
// * IntPtr (nuint)
// And we add and remove following:
// * Add Single -- CLR and CoreCLR support it.
// * Add Double -- CLR and CoreCLR support it.
// * Remove IntPtr -- CLR and CoreCLR do not support it, and CLI spec does not allow native int typed literal.
// * Remove UIntPtr -- CLR and CoreCLR do not support it, and CLI spec does not allow native unsigned int typed literal.

var types =
	new []
	{
		typeof(Int32),
		typeof(Int64),
		typeof(UInt32),
		typeof(UInt64),
		typeof(Byte),
		typeof(Int16),
		typeof(SByte),
		typeof(UInt16),
		typeof(Boolean),
		typeof(Char),
		typeof(Single),
		typeof(Double),
	};
var treats =
	new Dictionary<Type, (NumberTreats Treats, int Precision)>
	{
		{ typeof(Int32),	(NumberTreats.SignedInteger,	4) },
		{ typeof(Int64),	(NumberTreats.SignedInteger,	8) },
		{ typeof(UInt32),	(NumberTreats.UnsignedInteger,	4) },
		{ typeof(UInt64),	(NumberTreats.UnsignedInteger,	8) },
		{ typeof(Byte),		(NumberTreats.UnsignedInteger,	1) },
		{ typeof(Int16),	(NumberTreats.SignedInteger,	2) },
		{ typeof(SByte),	(NumberTreats.SignedInteger,	1) },
		{ typeof(UInt16),	(NumberTreats.UnsignedInteger,	2) },
		{ typeof(Boolean),	(NumberTreats.None,				0) },
		{ typeof(Char),		(NumberTreats.None,				2) },
		{ typeof(Single),	(NumberTreats.Real,				40) },
		{ typeof(Double),	(NumberTreats.Real,				80) },
	};

#>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;

namespace MsgPack.Serialization
{
	internal partial class SerializerFactory
	{
		private static Type GetEnumSerializerGenericTypeDefinition(Type underlyingType)
		{
<#
foreach (var type in types)
{
	var typeName = GetTypeName(type);
#>
			if (underlyingType == typeof(<#= type #>))
			{
				return typeof(BuiltinSerializers.<#= typeName #><>);
			}

<#
}
#>
			Throw.UnsupportedEnumUnderlyingType(underlyingType);
			return null!; // Never reaches
		}
	}

<#
foreach (var type in types)
{
	var typeName = GetTypeName(type);
#>
}

namespace MsgPack.Serialization.BuiltinSerializers
{
	internal sealed class <#= typeName #><T> : EnumSerializer<T>
		where T : unmanaged // Enums are always unmanaged
	{
		public <#= typeName #>(
			SerializerProvider ownerProvider,
			EnumSerializationMethod? method,
			NameMapper nameMapper,
#pragma warning disable CS8714 
			Dictionary<T, string> serializationNameMapping, 
#pragma warning restore CS8714 
			Dictionary<string, T> deserializationNameMapping
		) : base (ownerProvider, method, nameMapper, serializationNameMapping, deserializationNameMapping) { }

		protected sealed override void SerializeUnderlyingValue(ref SerializationOperationContext context, T value, IBufferWriter<byte> sink)
		{
<#
	WriteSerialize(type, treats[type]);
#>
		}

		protected sealed override T FromBoolean(bool value)
		{
<#
	WriteFrom(typeof(bool), type, treats);
#>
		}

		protected sealed override T FromChar(char value)
		{
<#
	WriteFrom(typeof(char), type, treats);
#>
		}

		protected sealed override T FromInt32(int value)
		{
<#
	WriteFrom(typeof(int), type, treats);
#>
		}

		protected sealed override T FromInt64(long value)
		{
<#
	WriteFrom(typeof(long), type, treats);
#>
		}

		protected sealed override T FromUInt64(ulong value)
		{
<#
	WriteFrom(typeof(ulong), type, treats);
#>
		}

		protected sealed override T FromSingle(float value)
		{
<#
	WriteFrom(typeof(float), type, treats);
#>
		}

		protected sealed override T FromDouble(double value)
		{
<#
	WriteFrom(typeof(double), type, treats);
#>
		}
	}
<#
}
#>

}
<#+
static string GetTypeName(Type targetType) => $"{targetType.Name}EnumSerializer";

void WriteSerialize(Type underlyingType, (NumberTreats, int) metadata)
{
	var (treats, precision) = metadata;

	if (underlyingType == typeof(char))
	{
#>
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				var c = *(char*)(&value);
				Span<char> input = stackalloc char[1];
				input[0] = c;
				context.Encoder.EncodeString(input, sink, context.StringEncoding);
			}
<#+
	}
	else
	{
		var suffix = underlyingType.Name;
		if (precision < 4 && precision != 0)
		{
			suffix = (treats & NumberTreats.Signed) == 0 ? "UInt32" : "Int32";
		}
#>
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				context.Encoder.Encode<#= suffix #>(*(<#= underlyingType.Name #>*)(&value), sink);
			}
<#+
	}
}

void WriteFrom(Type sourceType, Type underlyingType, IReadOnlyDictionary<Type, (NumberTreats Treats, int Precision)> metadata)
{
	if (sourceType == underlyingType)
	{
#>
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
<#+
		return;
	}

	var source = metadata[sourceType];
	var underlying = metadata[underlyingType];

	if ((source.Treats & NumberTreats.Number) == 0 || (underlying.Treats & NumberTreats.Number) == 0)
	{
#>
			Throw.IncompatibleEnumUnderlyingValue(typeof(<#= sourceType.Name #>), typeof(T), typeof(<#= underlyingType.Name#>));
			return default!; // Never reaches.
<#+
		return;
	}

	// Now, number.

	var sourceSigned = (source.Treats & NumberTreats.Signed) != 0;
	var underlyingSigned = (underlying.Treats & NumberTreats.Signed) != 0;

	// check range.
	if (underlying.Precision <= source.Precision)
	{

		// signed -> unsigned
		if (sourceSigned == underlyingSigned)
		{
			// simple range check
			if (sourceSigned)
			{
#>
			if (value < <#= underlyingType.Name #>.MinValue || value > <#= underlyingType.Name #>.MaxValue)
<#+
			}
			else
			{
#>
			if (value > <#= underlyingType.Name #>.MaxValue)
<#+
			}
		}
		else if (sourceSigned && !underlyingSigned)
		{
			// signed -> unsigned
			if (underlying.Precision < source.Precision)
			{
#>
			if (value < 0 || value > <#= underlyingType.Name #>.MaxValue)
<#+
			}
			else
			{
#>
			if (value < 0)
<#+
			}
		}
		else
		{
			// unsigned -> signed
#>
			if (value > (<#= sourceType.Name #>)<#= underlyingType.Name #>.MaxValue)
<#+
		}
#>
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(<#= sourceType.Name #>), typeof(T), typeof(<#= underlyingType.Name#>), value);
			}
<#+
	}
	else if (!sourceSigned && underlyingSigned && (underlying.Treats & NumberTreats.Integral) != 0)
	{
		// unsigned -> signed
#>
			if (value > (<#= sourceType.Name #>)<#= underlyingType.Name #>.MaxValue)
			{
				Throw.OutOfRangeEnumUnderlyingValue(typeof(<#= sourceType.Name #>), typeof(T), typeof(<#= underlyingType.Name#>), value);
			}
<#+
	}
#>
			var underlyingValue = unchecked((<#= underlyingType.Name #>)value);
			// Avoid Unsafe because of .NET 3.5 support.
			unsafe
			{
				return *(T*)(&value);
			}
<#+
#>

<#+
}

[Flags]
enum NumberTreats
{
	None = 0,
	Number = 0x1,
	Signed = 0x2,
	Integral = 0x4,
	SignedInteger = Number | Signed | Integral,
	UnsignedInteger = Number | Integral,
	Real = Number | Signed
}
#>
