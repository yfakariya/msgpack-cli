// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System.Diagnostics;

namespace MsgPack.Serialization
{
	internal static class Diagnostic
	{
		public static class General
		{
			private static readonly DiagnosticSource Source = new DiagnosticListener("MsgPack.Serialization");

			public static bool IsEnabled(string key)
				=> Source.IsEnabled(key);

			public static class Keys
			{
				public const string AotError = "AotError";
				public const string HoistUpInnerExceptionFailed = "HoistUpInnerExceptionFailed";
			}

			public static void AotError(object data)
				=> Source.Write(Keys.AotError, data);

			public static void HoistUpInnerExceptionFailed(object data)
				=> Source.Write(Keys.HoistUpInnerExceptionFailed, data);
		}

		public static class GeneratorTrace
		{
			private static readonly DiagnosticSource Source = new DiagnosticListener("MsgPack.Serialization.Generators.Trace");

			public static bool IsEnabled(string key)
				=> Source.IsEnabled(key);

			public static class Keys
			{
				public const string DetectedAsDeserializable = "DetectedAsDeserializable";
				public const string DeserializationConstructorFound = "DeserializationConstructorFound";
				public const string SkipStaticMember = "SkipStaticMember";
				public const string SkipIndexer = "SkipIndexer";
				public const string SkipSetOnlyProperty = "SkipSetOnlyProperty";
				public const string SkipMemberDueToAccessibility = "SkipMemberDueToAccessibility";
				public const string UseCollectionAddForReadOnlyMember = "UseCollectionAddForReadOnlyMember";
				public const string UseConstructorForMemberAccessDueToAccessibility = "UseConstructorForMemberAccessDueToAccessibility";
				public const string UseConstructorForMemberAccessDueToReadOnly = "UseConstructorForMemberAccessDueToReadOnly";
				public const string UseDelegateForMemberAccess = "UseDelegateForMemberAccess";
				public const string UseDirectMemberAccessDueToPublic = "UseDirectMemberAccessDueToPublic";
				public const string UseDirectMemberAccessDueToInternalsVisibleTo = "UseDirectMemberAccessDueToInternalsVisibleTo";
				public const string UseIgnoreAccessChecksToAttributeForMemberAccess = "UseIgnoreAccessChecksToAttributeForMemberAccess";
				public const string UseReflectionMemberAccess = "UseReflectionMemberAccess";
				public const string WillBeAsymmetricDueToReadOnlyMember = "WillBeAsymmetricDueToReadOnlyMember";
			}

			public static void DetectedAsDeserializable(object data)
				=> Source.Write(Keys.DetectedAsDeserializable, data);

			public static void DeserializationConstructorFound(object data)
				=> Source.Write(Keys.DeserializationConstructorFound, data);

			public static void SkipStaticMember(object data)
				=> Source.Write(Keys.SkipStaticMember, data);

			public static void SkipIndexer(object data)
				=> Source.Write(Keys.SkipIndexer, data);

			public static void SkipSetOnlyProperty(object data)
				=> Source.Write(Keys.SkipSetOnlyProperty, data);

			public static void SkipMemberDueToAccessibility(object data)
				=> Source.Write(Keys.SkipMemberDueToAccessibility, data);

			public static void UseCollectionAddForReadOnlyMember(object data)
				=> Source.Write(Keys.UseCollectionAddForReadOnlyMember, data);

			public static void UseConstructorForMemberAccessDueToAccessibility(object data)
				=> Source.Write(Keys.UseConstructorForMemberAccessDueToAccessibility, data);

			public static void UseConstructorForMemberAccessDueToReadOnly(object data)
				=> Source.Write(Keys.UseConstructorForMemberAccessDueToReadOnly, data);

			public static void UseDelegateForMemberAccess(object data)
				=> Source.Write(Keys.UseDelegateForMemberAccess, data);

			public static void UseDirectMemberAccessDueToPublic(object data)
				=> Source.Write(Keys.UseDirectMemberAccessDueToPublic, data);

			public static void UseDirectMemberAccessDueToInternalsVisibleTo(object data)
				=> Source.Write(Keys.UseDirectMemberAccessDueToInternalsVisibleTo, data);

			public static void UseIgnoreAccessChecksToAttributeForMemberAccess(object data)
				=> Source.Write(Keys.UseIgnoreAccessChecksToAttributeForMemberAccess, data);

			public static void UseReflectionMemberAccess(object data)
				=> Source.Write(Keys.UseReflectionMemberAccess, data);

			public static void WillBeAsymmetricDueToReadOnlyMember(object data)
				=> Source.Write(Keys.WillBeAsymmetricDueToReadOnlyMember, data);
		}

		public static class PolymorphicTrace
		{
			private static readonly DiagnosticSource Source = new DiagnosticListener("MsgPack.Serialization.Generators.Polymorphic.Trace");

			public static bool IsEnabled(string key)
				=> Source.IsEnabled(key);

			public static class Keys
			{
				public const string DefaultSchemaForValueType = "DefaultSchemaForValueType";
				public const string SchemaCreatedForRootType = "SchemaCreatedForRootType";
				public const string DefaultSchemaForUnqualifiedCollectionMember = "DefaultSchemaForUnqualifiedCollectionMember";
				public const string SchemaCreatedForCollectionMember = "SchemaCreatedForCollectionMember";
				public const string DefaultSchemaForUnqualifiedDictionaryMember = "DefaultSchemaForUnqualifiedDictionaryMember";
				public const string SchemaCreatedForDictionaryMember = "SchemaCreatedForDictionaryMember";
				public const string DefaultSchemaForUnqualifiedTupleMember = "DefaultSchemaForUnqualifiedTupleMember";
				public const string SchemaCreatedForTupleMember = "SchemaCreatedForTupleMember";
				public const string DefaultSchemaForUnqualifiedObjectMember = "DefaultSchemaForUnqualifiedObjectMember";
				public const string SchemaCreatedForObjectMember = "SchemaCreatedForObjectMember";
			}

			public static void DefaultSchemaForValueType(object data)
				=> Source.Write(Keys.DefaultSchemaForValueType, data);

			public static void SchemaCreatedForRootType(object data)
				=> Source.Write(Keys.SchemaCreatedForRootType, data);

			public static void DefaultSchemaForUnqualifiedCollectionMember(object data)
				=> Source.Write(Keys.DefaultSchemaForUnqualifiedCollectionMember, data);

			public static void SchemaCreatedForCollectionMember(object data)
				=> Source.Write(Keys.SchemaCreatedForCollectionMember, data);

			public static void DefaultSchemaForUnqualifiedDictionaryMember(object data)
				=> Source.Write(Keys.DefaultSchemaForUnqualifiedDictionaryMember, data);

			public static void SchemaCreatedForDictionaryMember(object data)
				=> Source.Write(Keys.SchemaCreatedForDictionaryMember, data);

			public static void DefaultSchemaForUnqualifiedTupleMember(object data)
				=> Source.Write(Keys.DefaultSchemaForUnqualifiedTupleMember, data);

			public static void SchemaCreatedForTupleMember(object data)
				=> Source.Write(Keys.SchemaCreatedForTupleMember, data);

			public static void DefaultSchemaForUnqualifiedObjectMember(object data)
				=> Source.Write(Keys.DefaultSchemaForUnqualifiedObjectMember, data);

			public static void SchemaCreatedForObjectMember(object data)
				=> Source.Write(Keys.SchemaCreatedForObjectMember, data);
		}

	}
}

