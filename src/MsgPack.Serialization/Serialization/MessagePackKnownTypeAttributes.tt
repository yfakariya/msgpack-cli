<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;

using MsgPack.Serialization.Polymorphic;

namespace MsgPack.Serialization
{
<#
foreach( var item in 
	new [] 
	{
		new 
		{ 
			Prefix = "",
			Summary = "Marks that the runtime type of this member should be encoded with closed type codes for polymorphism.",
			RemarksLines = 
				new string[]
				{
					"When you apply this attribute to a member, the member",
				},
			Target = "Member",
			OmitConstructor = false,
			CanQualifyType = true,
		},
		new 
		{ 
			Prefix =  "CollectionItem",
			Summary = "Marks that the runtime type of items/values of this collection/dictionary should be encoded with closed type codes for polymorphism.",
			RemarksLines = 
				new string[]
				{
					"When you apply this attribute to a member, the items/values of the collection/dictionary",
				},
			Target = "CollectionItem",
			OmitConstructor = false,
			CanQualifyType = true,
		},
		new 
		{ 
			Prefix = "DictionaryKey",
			Summary = "Marks that the runtime type of keys of this dictionary should be encoded with closed type codes for polymorphism.",
			RemarksLines = 
				new string[]
				{
					"When you apply this attribute to a member, the keys of the dictionary",
				},
			Target = "DictionaryKey",
			OmitConstructor = false,
			CanQualifyType = true,
		},
		new 
		{ 
			Prefix =  "TupleItem",
			Summary = "Marks that the runtime type of specified item of the tuple should be encoded with closed type codes for polymorphism.",
			RemarksLines = 
				new string[]
				{
					"When you apply this attribute to a member, the item of tuple,",
				},
			Target = "TupleItem",
			OmitConstructor = true,
			CanQualifyType = false,
		},
	}
 )
{
	var typeName = "MessagePackKnown" + item.Prefix + "TypeAttribute";
#>
	/// <summary>
	///		<#= item.Summary #>
	/// 	
	/// </summary>
	/// <remarks>
<#
	foreach ( var remarksLine in item.RemarksLines )
	{
#>
	/// 	<#= remarksLine #>
<#
	}
#>
	///		will be serialized as 2 element array as [ &lt;type-code&gt;, &lt;actual-value (array or map)&gt;] format 
	///		where the type-code is utf-8 encoded string representing type in your application (system) context.
	///		When you interop with other launages, the deserializer will be able to deserialize object which is actual type when serialized with interoperability.
	///		<note>
	///			You must use one-to-one relationship between type-code and the type.
	///		</note>
	/// </remarks>
<#
	if ( item.CanQualifyType )
	{
#>
	[AttributeUsage( AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface | AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = true )]
<#
	}
	else
	{
#>
	[AttributeUsage( AttributeTargets.Field | AttributeTargets.Property, AllowMultiple = true )]
<#
	}
#>
	public sealed <#= item.OmitConstructor ? "partial " : String.Empty #>class <#= typeName #> : Attribute, IPolymorphicKnownTypeAttribute
	{
		PolymorphismTarget IPolymorphicHelperAttribute.Target => PolymorphismTarget.<#= item.Target #>;

		/// <summary>
		///		Gets a type code to be bound.
		/// </summary>
		/// <value>
		///		A type code to be bound.
		/// </value>
		public string TypeCode { get; }

		/// <summary>
		///		Gets the type of the binding <see cref="Type"/> for <see cref="TypeCode"/>.
		/// </summary>
		/// <value>
		///		The binding <see cref="Type"/> for <see cref="TypeCode"/>.
		/// </value>
		public Type BindingType { get; }
<#
	if ( !item.OmitConstructor )
	{
#>

		/// <summary>
		///		Initializes a new instance of the <see cref="<#= typeName #>"/> class.
		/// </summary>
		/// <param name="typeCode">A string type code to be bound.</param>
		/// <param name="bindingType">The binding <see cref="Type"/> for <paramref name="typeCode"/>.</param>
		public <#= typeName #>( string typeCode, Type bindingType )
		{
			this.TypeCode = typeCode;
			this.BindingType = bindingType;
		}
<#
	}
#>
	}

<#
}
#>
	partial class MessagePackKnownTupleItemTypeAttribute : IPolymorphicTupleItemTypeAttribute
	{
		/// <summary>
		///		Gets the target tuple item's number.
		/// </summary>
		/// <value>
		///		The 1-based target tuple item's number.
		/// </value>
		/// <remarks>
		///		<para>
		///			If this value is not valid for the tuple, this whole instance should be ignored.
		///		</para>
		///		<para>
		///			If same values are specified multiply, the result is undefined.
		///		</para>
		/// </remarks>
		public int ItemNumber { get; }

		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackKnownTupleItemTypeAttribute"/> class.
		/// </summary>
		/// <param name="itemNumber">The 1-based target item number of the tuple. The attribute which has invalid value should be ignored.</param>
		/// <param name="typeCode">A string type code to be bound.</param>
		/// <param name="bindingType">The binding <see cref="Type"/> for <paramref name="typeCode"/>.</param>
		public MessagePackKnownTupleItemTypeAttribute( int itemNumber, string typeCode, Type bindingType )
		{
			this.ItemNumber = itemNumber;
			this.TypeCode = typeCode;
			this.BindingType = bindingType;
		}
	}
}
