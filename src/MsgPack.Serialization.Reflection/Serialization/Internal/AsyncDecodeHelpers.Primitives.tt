<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ output extension=".cs" #>
<#
var types =
	new []
	{
		typeof(sbyte),
		typeof(short),
		typeof(int),
		typeof(long),
		typeof(byte),
		typeof(ushort),
		typeof(uint),
		typeof(ulong),
		typeof(bool),
		typeof(float),
		typeof(double),
	}.Select(t => (Name: t.Name, Type: t.Name, IsReferenceType: false))
	.Concat(
		new []
		{
			(Name: "String", Type: "String", IsReferenceType: true),
			(Name: "Binary", Type: "byte[]", IsReferenceType: true)
		}
	).ToArray();
#>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

using MsgPack.Internal;

namespace MsgPack.Serialization.Internal
{
	partial class AsyncDecodeHelpers
	{
<#
foreach (var type in types)
{
	foreach (var isNullable in new [] { false, true })
	{
		var methodName = $"Decode{(isNullable ? "Nullable" : String.Empty)}{type.Name}";
		var returnType = $"{type.Type}{(isNullable ? "?" : String.Empty)}";
#>
		public static async ValueTask<<#= returnType #>> <#= methodName #>Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			<#= returnType #> result;
			while (!Try<#= methodName #>(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool Try<#= methodName #>(FormatDecoder decoder, ReadOnlyStreamSequence source, out <#= returnType #> result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.<#= methodName #>(ref reader, out requestHint)<#= (!isNullable && type.IsReferenceType) ? "!" : String.Empty #>;
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

<#
	}
}
#>
	}
}
