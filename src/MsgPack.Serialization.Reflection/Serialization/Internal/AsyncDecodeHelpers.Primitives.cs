// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

using MsgPack.Internal;

namespace MsgPack.Serialization.Internal
{
	partial class AsyncDecodeHelpers
	{
		public static async ValueTask<SByte> DecodeSByteAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			SByte result;
			while (!TryDecodeSByte(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeSByte(FormatDecoder decoder, ReadOnlyStreamSequence source, out SByte result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeSByte(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<SByte?> DecodeNullableSByteAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			SByte? result;
			while (!TryDecodeNullableSByte(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableSByte(FormatDecoder decoder, ReadOnlyStreamSequence source, out SByte? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableSByte(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int16> DecodeInt16Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int16 result;
			while (!TryDecodeInt16(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeInt16(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int16 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeInt16(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int16?> DecodeNullableInt16Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int16? result;
			while (!TryDecodeNullableInt16(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableInt16(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int16? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableInt16(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int32> DecodeInt32Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int32 result;
			while (!TryDecodeInt32(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeInt32(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int32 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeInt32(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int32?> DecodeNullableInt32Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int32? result;
			while (!TryDecodeNullableInt32(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableInt32(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int32? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableInt32(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int64> DecodeInt64Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int64 result;
			while (!TryDecodeInt64(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeInt64(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int64 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeInt64(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Int64?> DecodeNullableInt64Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Int64? result;
			while (!TryDecodeNullableInt64(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableInt64(FormatDecoder decoder, ReadOnlyStreamSequence source, out Int64? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableInt64(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Byte> DecodeByteAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Byte result;
			while (!TryDecodeByte(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeByte(FormatDecoder decoder, ReadOnlyStreamSequence source, out Byte result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeByte(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Byte?> DecodeNullableByteAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Byte? result;
			while (!TryDecodeNullableByte(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableByte(FormatDecoder decoder, ReadOnlyStreamSequence source, out Byte? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableByte(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt16> DecodeUInt16Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt16 result;
			while (!TryDecodeUInt16(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeUInt16(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt16 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeUInt16(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt16?> DecodeNullableUInt16Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt16? result;
			while (!TryDecodeNullableUInt16(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableUInt16(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt16? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableUInt16(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt32> DecodeUInt32Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt32 result;
			while (!TryDecodeUInt32(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeUInt32(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt32 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeUInt32(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt32?> DecodeNullableUInt32Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt32? result;
			while (!TryDecodeNullableUInt32(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableUInt32(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt32? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableUInt32(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt64> DecodeUInt64Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt64 result;
			while (!TryDecodeUInt64(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeUInt64(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt64 result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeUInt64(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<UInt64?> DecodeNullableUInt64Async(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			UInt64? result;
			while (!TryDecodeNullableUInt64(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableUInt64(FormatDecoder decoder, ReadOnlyStreamSequence source, out UInt64? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableUInt64(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Boolean> DecodeBooleanAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Boolean result;
			while (!TryDecodeBoolean(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeBoolean(FormatDecoder decoder, ReadOnlyStreamSequence source, out Boolean result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeBoolean(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Boolean?> DecodeNullableBooleanAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Boolean? result;
			while (!TryDecodeNullableBoolean(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableBoolean(FormatDecoder decoder, ReadOnlyStreamSequence source, out Boolean? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableBoolean(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Single> DecodeSingleAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Single result;
			while (!TryDecodeSingle(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeSingle(FormatDecoder decoder, ReadOnlyStreamSequence source, out Single result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeSingle(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Single?> DecodeNullableSingleAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Single? result;
			while (!TryDecodeNullableSingle(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableSingle(FormatDecoder decoder, ReadOnlyStreamSequence source, out Single? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableSingle(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Double> DecodeDoubleAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Double result;
			while (!TryDecodeDouble(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeDouble(FormatDecoder decoder, ReadOnlyStreamSequence source, out Double result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeDouble(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<Double?> DecodeNullableDoubleAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			Double? result;
			while (!TryDecodeNullableDouble(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableDouble(FormatDecoder decoder, ReadOnlyStreamSequence source, out Double? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableDouble(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<String> DecodeStringAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			String result;
			while (!TryDecodeString(decoder, source, encoding: null, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		public static async ValueTask<String> DecodeStringAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, Encoding? encoding, CancellationToken cancellationToken)
		{
			String result;
			while (!TryDecodeString(decoder, source, encoding, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeString(FormatDecoder decoder, ReadOnlyStreamSequence source, Encoding? encoding, out String result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeString(ref reader, out requestHint, encoding, cancellationToken)!;
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<String?> DecodeNullableStringAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			String? result;
			while (!TryDecodeNullableString(decoder, source, encoding: null, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		public static async ValueTask<String?> DecodeNullableStringAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, Encoding? encoding, CancellationToken cancellationToken)
		{
			String? result;
			while (!TryDecodeNullableString(decoder, source, encoding, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableString(FormatDecoder decoder, ReadOnlyStreamSequence source, Encoding? encoding, out String? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableString(ref reader, out requestHint, encoding, cancellationToken);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<byte[]> DecodeBinaryAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			byte[] result;
			while (!TryDecodeBinary(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeBinary(FormatDecoder decoder, ReadOnlyStreamSequence source, out byte[] result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeBinary(ref reader, out requestHint)!;
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

		public static async ValueTask<byte[]?> DecodeNullableBinaryAsync(this FormatDecoder decoder, ReadOnlyStreamSequence source, CancellationToken cancellationToken)
		{
			byte[]? result;
			while (!TryDecodeNullableBinary(decoder, source, out result, out var requestHint, cancellationToken))
			{
				await source.FetchAsync(requestHint, cancellationToken).ConfigureAwait(false);
			}

			return result;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private static bool TryDecodeNullableBinary(FormatDecoder decoder, ReadOnlyStreamSequence source, out byte[]? result, out int requestHint, CancellationToken cancellationToken)
		{
			var reader = new SequenceReader<byte>(source.Sequence);
			result = decoder.DecodeNullableBinary(ref reader, out requestHint);
			source.Advance(reader.Consumed);
			return requestHint == 0;
		}

	}
}
