// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class MessagePackDecoder
	{
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override SByte DecodeSByte(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeSignedInteger(ref source, typeof(SByte), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < SByte.MinValue || result > SByte.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(SByte));
			}

			return unchecked((SByte)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Int16 DecodeInt16(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeSignedInteger(ref source, typeof(Int16), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < Int16.MinValue || result > Int16.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(Int16));
			}

			return unchecked((Int16)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Int32 DecodeInt32(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeSignedInteger(ref source, typeof(Int32), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < Int32.MinValue || result > Int32.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(Int32));
			}

			return unchecked((Int32)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Int64 DecodeInt64(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeSignedInteger(ref source, typeof(Int64), out var header, out var result, out requestHint))
			{
				return default;
			}
			return unchecked((Int64)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Byte DecodeByte(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeUnsignedInteger(ref source, typeof(Byte), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < Byte.MinValue || result > Byte.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(Byte));
			}

			return unchecked((Byte)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override UInt16 DecodeUInt16(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeUnsignedInteger(ref source, typeof(UInt16), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < UInt16.MinValue || result > UInt16.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(UInt16));
			}

			return unchecked((UInt16)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override UInt32 DecodeUInt32(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeUnsignedInteger(ref source, typeof(UInt32), out var header, out var result, out requestHint))
			{
				return default;
			}
			if (result < UInt32.MinValue || result > UInt32.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(UInt32));
			}

			return unchecked((UInt32)result);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override UInt64 DecodeUInt64(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryDecodeUnsignedInteger(ref source, typeof(UInt64), out var header, out var result, out requestHint))
			{
				return default;
			}
			return unchecked((UInt64)result);
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private bool TryDecodeSignedInteger(ref SequenceReader<byte> source, Type type, out byte header, out Int64 value, out int requestHint)
		{
			if (!source.TryPeek(out header))
			{
				requestHint = 1;
				value = default;
				return false;
			}

			requestHint = 0;

			if (header < 128)
			{
				value = header;
				source.Advance(1);
				return true;
			}

			if (header >= 0xE0)
			{
				value = unchecked((sbyte)header);
				source.Advance(1);
				return true;
			}

			return this.TryDecodeSignedIntegerSlow(ref source, type, header, out value, out requestHint);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool TryDecodeSignedIntegerSlow(ref SequenceReader<byte> source, Type type, byte header, out Int64 value, out int requestHint)
		{
			ParseNumberHeader(header, ref source, type, out var length, out var kind);

			if ((kind & NumberKind.RealBitMask) != 0 && !this.Options.CanTreatRealAsInteger)
			{
				MessagePackThrow.RealCannotBeInteger(header, source.Consumed, type);
			}

			switch (kind)
			{
				case NumberKind.Signed:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadSByte(ref source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<short>(ref source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<int>(ref source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<long>(ref source, offset: 1, out requestHint);
							break;
						}
					}

					if (requestHint != 0)
					{
						value = default;
						return false;
					}
					break;
				}
				case NumberKind.Unsigned:
				{
					ulong unsigned;
					switch (length)
					{
						case 1:
						{
							unsigned = ReadByte(ref source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							unsigned = ReadValue<ushort>(ref source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							unsigned = ReadValue<uint>(ref source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							unsigned = ReadValue<ulong>(ref source, offset: 1, out requestHint);
							break;
						}
					}

					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (unsigned > Int64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((Int64)unsigned);
					break;
				}
				case NumberKind.Single:
				{
					var real = ReadValue<float>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > Int64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < Int64.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((Int64)real);
					break;
				}
				default:
				{
					Debug.Assert(kind == NumberKind.Double, $"kind({kind}) == NumberType.Double");
					var real = ReadValue<double>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > Int64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < Int64.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((Int64)real);
					break;
				}
			}

			return true;
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private bool TryDecodeUnsignedInteger(ref SequenceReader<byte> source, Type type, out byte header, out UInt64 value, out int requestHint)
		{
			if (!source.TryPeek(out header))
			{
				requestHint = 1;
				value = default;
				return false;
			}

			requestHint = 0;

			if (header < 128)
			{
				value = header;
				source.Advance(1);
				return true;
			}

			return this.TryDecodeUnsignedIntegerSlow(ref source, type, header, out value, out requestHint);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool TryDecodeUnsignedIntegerSlow(ref SequenceReader<byte> source, Type type, byte header, out UInt64 value, out int requestHint)
		{
			ParseNumberHeader(header, ref source, type, out var length, out var kind);

			if ((kind & NumberKind.RealBitMask) != 0 && !this.Options.CanTreatRealAsInteger)
			{
				MessagePackThrow.RealCannotBeInteger(header, source.Consumed, type);
			}

			switch (kind)
			{
				case NumberKind.Signed:
				{
					long signed;
					switch (length)
					{
						case 1:
						{
							signed = ReadSByte(ref source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							signed = ReadValue<short>(ref source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							signed = ReadValue<int>(ref source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							signed = ReadValue<long>(ref source, offset: 1, out requestHint);
							break;
						}
					}

					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (signed < 0)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((ulong)signed);
					break;
				}
				case NumberKind.Unsigned:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadByte(ref source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<ushort>(ref source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<uint>(ref source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<ulong>(ref source, offset: 1, out requestHint);
							break;
						}
					}

					if (requestHint != 0)
					{
						value = default;
						return false;
					}
					break;
				}
				case NumberKind.Single:
				{
					var real = ReadValue<float>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > UInt64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < UInt64.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((UInt64)real);
					break;
				}
				default:
				{
					Debug.Assert(kind == NumberKind.Double, $"kind({kind}) == NumberType.Double");
					var real = ReadValue<double>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > UInt64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < UInt64.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((UInt64)real);
					break;
				}
			}

			return true;
		}

	}
}
