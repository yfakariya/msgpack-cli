// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace MsgPack.Internal
{
	public partial class MessagePackDecoder
	{
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override string? DecodeNullableString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeString(ref source, out requestHint, encoding, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override string? DecodeString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeStringHeader(ref source, out _, out requestHint, out var consumed);
			if (requestHint != 0)
			{
				return default;
			}

			if (source.Remaining < length)
			{
				requestHint = (int)((length - source.Remaining) & Int32.MaxValue);
				return default;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.StringLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if (encoding == null && length <= this.Options.CancellationSupportThreshold)
			{
				// fast-path
				var result = Utf8EncodingNonBomStrict.Instance.GetString(source.UnreadSpan.Slice(0, (int)length));
				source.Advance(length);
				requestHint = 0;
				return result;
			}
			else
			{
				var result = (encoding ?? Utf8EncodingNonBomStrict.Instance).GetStringMultiSegment(source.Sequence.Slice(source.Position), this.Options.CharBufferPool, cancellationToken);
				source.Advance(length);
				requestHint = 0;
				return result;
			}
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int? DecodeNullableString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeString(ref source, buffer, out requestHint, encoding, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int DecodeString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeStringHeader(ref source, out _, out requestHint, out var consumed);
			if (requestHint != 0)
			{
				return default;
			}

			if (source.Remaining < length)
			{
				requestHint = (int)((length - source.Remaining) & Int32.MaxValue);
				return default;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.StringLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if (encoding == null && length <= this.Options.CancellationSupportThreshold)
			{
				// fast-path
				var result = Utf8EncodingNonBomStrict.Instance.GetChars(source.UnreadSpan.Slice(0, (int)length), buffer);
				source.Advance(length);
				requestHint = 0;
				return result;
			}
			else
			{
				var result = (encoding ?? Utf8EncodingNonBomStrict.Instance).GetStringMultiSegmentTo(source.Sequence.Slice(source.Position), buffer, cancellationToken);
				source.Advance(length);
				requestHint = 0;
				return result;
			}
		}


		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override byte[]? DecodeNullableBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeBinary(ref source, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override byte[]? DecodeBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeBinaryHeader(ref source, out requestHint, out var consumed);
			if(requestHint != 0)
			{
				return default;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.BinaryLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if(source.Remaining < length)
			{
				requestHint = length - (int)source.Remaining;
				return default;
			}

			// This line may throw OutOfMemoryException, but we cannot determine the OOM is caused by heap exhausion or excess of the implementation specific max length of arrays.
			// So, we just throws OOM for such conditions.
			var result = new byte[length];
			var shouldBeTrue = source.TryCopyTo(result);
			Debug.Assert(shouldBeTrue, "SequenceReader<byte>.Remaining lied.");
			source.Advance(length);
			return result;
		}


		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int? DecodeNullableBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeBinary(ref source, buffer, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int DecodeBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeBinaryHeader(ref source, out requestHint, out var consumed);
			if(requestHint != 0)
			{
				return default;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.BinaryLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if(source.Remaining < length)
			{
				requestHint = length - (int)source.Remaining;
				return default;
			}

			var shouldBeTrue = source.TryCopyTo(buffer);
			Debug.Assert(shouldBeTrue, "SequenceReader<byte>.Remaining lied.");
			source.Advance(length);
			return length;
		}

	}
}
