<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace MsgPack.Internal
{
	public partial class MessagePackDecoder
	{
<#
foreach (var isSpan in new [] { false, true })
{
	var returnType = isSpan ? "int" : "string";
	var bufferParameter = isSpan ? "Span<char> buffer, " : String.Empty;
	var bufferArgument = isSpan ? "buffer, " : String.Empty;
#>
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= returnType #>? DecodeNullableString(ref SequenceReader<byte> source, <#= bufferParameter #>out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeString(ref source, <#= bufferArgument #>out requestHint, encoding, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= returnType #> DecodeString(ref SequenceReader<byte> source, <#= bufferParameter #>out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeStringHeader(ref source, out _, out requestHint, out var consumed);
			if (requestHint != 0)
			{
				return default!;
			}

			if (source.Remaining < length)
			{
				requestHint = (int)((length - source.Remaining) & Int32.MaxValue);
				return default!;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.StringLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if (encoding == null && length <= this.Options.CancellationSupportThreshold)
			{
				// fast-path
<#
	if (isSpan)
	{
#>
				var result = Utf8EncodingNonBomStrict.Instance.GetChars(source.UnreadSpan.Slice(0, (int)length), buffer);
<#
	}
	else
	{
#>
				var result = Utf8EncodingNonBomStrict.Instance.GetString(source.UnreadSpan.Slice(0, (int)length));
<#
	}
#>
				source.Advance(length);
				requestHint = 0;
				return result;
			}
			else
			{
<#
	if (isSpan)
	{
#>
				var result = (encoding ?? Utf8EncodingNonBomStrict.Instance).GetStringMultiSegmentTo(source.Sequence.Slice(source.Position), buffer, cancellationToken);
<#
	}
	else
	{
#>
				var result = (encoding ?? Utf8EncodingNonBomStrict.Instance).GetStringMultiSegment(source.Sequence.Slice(source.Position), this.Options.CharBufferPool, cancellationToken);
<#
	}
#>
				source.Advance(length);
				requestHint = 0;
				return result;
			}
		}

<#
}

foreach (var isSpan in new [] { false, true })
{
	var returnType = isSpan ? "int" : "byte[]";
	var bufferParameter = isSpan ? "Span<byte> buffer, " : String.Empty;
	var bufferArgument = isSpan ? "buffer, " : String.Empty;
#>

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= returnType #>? DecodeNullableBinary(ref SequenceReader<byte> source, <#= bufferParameter #>out int requestHint, CancellationToken cancellationToken = default)
		{
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeBinary(ref source, <#= bufferArgument #>out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= returnType #> DecodeBinary(ref SequenceReader<byte> source, <#= bufferParameter #>out int requestHint, CancellationToken cancellationToken = default)
		{
			var length = this.DecodeBinaryHeader(ref source, out requestHint, out var consumed);
			if(requestHint != 0)
			{
				return default!;
			}

			if (length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.BinaryLengthExceeded(source.Consumed - consumed, length, this.Options.MaxBinaryLengthInBytes);
			}

			if(source.Remaining < length)
			{
				requestHint = length - (int)source.Remaining;
				return default!;
			}

<#
	if (isSpan)
	{
#>
			var shouldBeTrue = source.TryCopyTo(buffer);
			Debug.Assert(shouldBeTrue, "SequenceReader<byte>.Remaining lied.");
			source.Advance(length);
			return length;
<#
	}
	else
	{
#>
			// This line may throw OutOfMemoryException, but we cannot determine the OOM is caused by heap exhausion or excess of the implementation specific max length of arrays.
			// So, we just throws OOM for such conditions.
			var result = new byte[length];
			var shouldBeTrue = source.TryCopyTo(result);
			Debug.Assert(shouldBeTrue, "SequenceReader<byte>.Remaining lied.");
			source.Advance(length);
			return result;
<#
	}
#>
		}

<#
}
#>
	}
}
