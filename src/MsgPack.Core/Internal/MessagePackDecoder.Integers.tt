<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="./MessagePackDecoder.Number.ttinclude" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class MessagePackDecoder
	{
<#
// -------------- Decode() -------------------

// Signed
foreach (var type in
	new []
	{
		"SByte",
		"Int16",
		"Int32"
	}
)
{
	this.WriteMethod(type, isSigned: true, is64Bit: false);
}

this.WriteMethod("Int64", isSigned: true, is64Bit: true);

// Unsigned
foreach (var type in
	new []
	{
		"Byte",
		"UInt16",
		"UInt32"
	}
)
{
	this.WriteMethod(type, isSigned: false, is64Bit: false);
}

this.WriteMethod("UInt64", isSigned: false, is64Bit: true);

// ------------- Decode[Uns|S]ignedInteger ------------
foreach (var isSigned in new [] { true, false })
{
	var methodName = $"TryDecode{(isSigned ? "Signed" : "Unsigned")}Integer";
	var outType = isSigned ? "Int64": "UInt64";
#>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private bool <#= methodName #>(ref SequenceReader<byte> source, Type type, out byte header, out <#= outType #> value, out int requestHint)
		{
			if (!source.TryPeek(out header))
			{
				requestHint = 1;
				value = default;
				return false;
			}

			requestHint = 0;

			if (header < 128)
			{
				value = header;
				source.Advance(1);
				return true;
			}

<#
	if (isSigned)
	{
#>
			if (header >= 0xE0)
			{
				value = unchecked((sbyte)header);
				source.Advance(1);
				return true;
			}

<#
	} // if (isSigned)
#>
			return this.<#= methodName #>Slow(ref source, type, header, out value, out requestHint);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private bool <#= methodName #>Slow(ref SequenceReader<byte> source, Type type, byte header, out <#= outType #> value, out int requestHint)
		{
			ParseNumberHeader(header, ref source, type, out var length, out var kind);

			if ((kind & NumberKind.RealBitMask) != 0 && !this.Options.CanTreatRealAsInteger)
			{
				MessagePackThrow.RealCannotBeInteger(header, source.Consumed, type);
			}

			switch (kind)
			{
				case NumberKind.Signed:
				{
<#
	if (isSigned)
	{
		WriteDecodeInteger("value", isSigned: true);
#>
					if (requestHint != 0)
					{
						value = default;
						return false;
					}
<#
	}
	else
	{
#>
					long signed;
<#
		WriteDecodeInteger("signed", isSigned: true);
#>
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (signed < 0)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((ulong)signed);
<#
	} // if (isSigned)
#>
					break;
				}
				case NumberKind.Unsigned:
				{
<#
	if (isSigned)
	{
#>
					ulong unsigned;
<#
		WriteDecodeInteger("unsigned", isSigned: false);
#>
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (unsigned > Int64.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((<#= outType #>)unsigned);
<#
	}
	else
	{
		WriteDecodeInteger("value", isSigned: false);
#>
					if (requestHint != 0)
					{
						value = default;
						return false;
					}
<#
	} // if (isSigned)
#>
					break;
				}
				case NumberKind.Single:
				{
					var real = ReadValue<float>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > <#= outType #>.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < <#= outType #>.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((<#= outType #>)real);
					break;
				}
				default:
				{
					Debug.Assert(kind == NumberKind.Double, $"kind({kind}) == NumberType.Double");
					var real = ReadValue<double>(ref source, offset: 1, out requestHint);
					if (requestHint != 0)
					{
						value = default;
						return false;
					}

					if (real > <#= outType #>.MaxValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					if (real < <#= outType #>.MinValue)
					{
						MessagePackThrow.IsNotType(header, source.Consumed, type);
					}

					value = unchecked((<#= outType #>)real);
					break;
				}
			}

			return true;
		}

<#
} // foreach (var isSigned)
#>
	}
}
<#+
void WriteMethod(string type, bool isSigned, bool is64Bit)
{
	var coreMethod = $"TryDecode{(isSigned ? "Signed" : "Unsigned")}Integer";
	var resultType = isSigned ? "long" : "ulong";
#>
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= type #> Decode<#= type #>(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!this.<#= coreMethod #>(ref source, typeof(<#= type #>), out var header, out var result, out requestHint))
			{
				return default;
			}
<#+
	if (!is64Bit)
	{
#>
			if (result < <#= type #>.MinValue || result > <#= type #>.MaxValue)
			{
				MessagePackThrow.IsNotType(header, source.Consumed, typeof(<#= type #>));
			}

<#+
	} // if (!is64Bit)
#>
			return unchecked((<#= type #>)result);
		}

<#+
}
#>
