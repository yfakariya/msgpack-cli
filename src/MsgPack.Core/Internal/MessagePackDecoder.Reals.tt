<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="./MessagePackDecoder.Number.ttinclude" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class MessagePackDecoder
	{
<#
foreach (var type in new [] { "Single", "Double" })
{
#>
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override <#= type #> Decode<#= type #>(ref SequenceReader<byte> source, out int requestHint)
		{
			if (!source.TryPeek(out var header))
			{
				requestHint = 1;
				return default;
			}

			requestHint = 0;

			if (header < 128 || header >= 0xE0)
			{
				source.Advance(1);
				return header;
			}

			ParseNumberHeader(header, ref source, typeof(<#= type #>), out var length, out var kind);

			<#= type #> value;
			switch (kind)
			{
				case NumberKind.Signed:
				{
<#
	WriteDecodeInteger("value", isSigned: true);
#>
					break;
				}
				case NumberKind.Unsigned:
				{
<#
	WriteDecodeInteger("value", isSigned: false);
#>
					break;
				}
				case NumberKind.Single:
				{
					value = ReadValue<float>(ref source, offset: 1, out requestHint);
					break;
				}
				default:
				{
					// Double
<#
	if (type != "Double")
	{
#>
					value = (<#= type #>)ReadValue<double>(ref source, offset: 1, out requestHint);
<#
	}
	else
	{
#>
					value = ReadValue<double>(ref source, offset: 1, out requestHint);
<#
	}
#>
					break;
				}
			}

			if (requestHint != 0)
			{
				return default;
			}

			return value;
		}

<#
} // foreach (var isSigned)
#>
	}
}
