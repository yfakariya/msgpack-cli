<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class MessagePackEncoder
	{
<#
foreach (var inputType in new []{ "Int32", "UInt32", "Int64", "UInt64" })
{
#>
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override void Encode<#= inputType #>(<#= inputType #> value, IBufferWriter<byte> buffer)
		{
			buffer = Ensure.NotNull(buffer);

			var leastByte = value & 0x000000FF;
			if (leastByte == value || (value ^ 0xFFFFFF00) == leastByte)
			{
				var span = buffer.GetSpan(1);
				span[0] = unchecked((byte)(leastByte));
				buffer.Advance(1);
			}
			else
			{
				this.EncodeSlow(value, buffer);
			}
		}

<#
} // public int/long
#>
		private void EncodeSlow(int value, IBufferWriter<byte> buffer)
		{
			if (value >= SByte.MinValue && value <= SByte.MaxValue)
			{
				// SingedInt8 (SByte)
				var span = buffer.GetSpan(2);
				span[1] = unchecked((byte)(sbyte)value);
				span[0] = MessagePackCode.SignedInt8;
				buffer.Advance(2);
			}
			else if (value >= Int16.MinValue && value <= Int16.MaxValue)
			{
<#
	WriteEncodeSlowBody("Int16", sizeof(short) + 1, "SignedInt16");
#>
			}
			else
			{
<#
	WriteEncodeSlowBody("Int32", sizeof(int) + 1, "SignedInt32");
#>
			}
		} // EncodeSlow(int)

		private void EncodeSlow(uint value, IBufferWriter<byte> buffer)
		{
			if (value <= Byte.MaxValue)
			{
				// UnsingedInt8 (Byte)
				var span = buffer.GetSpan(2);
				span[1] = unchecked((byte)value);
				span[0] = MessagePackCode.UnsignedInt8;
				buffer.Advance(2);
			}
			else if (value <= UInt16.MaxValue)
			{
<#
	WriteEncodeSlowBody("UInt16", sizeof(ushort) + 1, "UnsignedInt16");
#>
			}
			else
			{
<#
	WriteEncodeSlowBody("UInt32", sizeof(uint) + 1, "UnsignedInt32");
#>
			}
		} // EncodeSlow(uint)

		private void EncodeSlow(long value, IBufferWriter<byte> buffer)
		{
			if (value <= Int32.MaxValue && value >= Int32.MinValue)
			{
				this.EncodeSlow(unchecked((int)value), buffer);
			}
			else
			{
<#
	WriteEncodeSlowBody("Int64", sizeof(long) + 1, "SignedInt64");
#>
			}
		} // EncodeSlow(long)

		private void EncodeSlow(ulong value, IBufferWriter<byte> buffer)
		{
			if (value <= UInt32.MaxValue)
			{
				this.EncodeSlow(unchecked((uint)value), buffer);
			}
			else
			{
<#
	WriteEncodeSlowBody("UInt64", sizeof(ulong) + 1, "UnsignedInt64");
#>
			}
		} // EncodeSlow(ulong)

	}
}

<#+
private void WriteEncodeSlowBody(string typeName, int size, string code)
{
#>
				// <#= code #> (<#= typeName #>)
				var span = buffer.GetSpan(<#= size #>);
				span[0] = MessagePackCode.<#= code #>;
				span = span.Slice(1);
				BinaryPrimitives.Write<#= typeName #>BigEndian(span, unchecked((<#= typeName #>)value));
				buffer.Advance(<#= size #>);
<#+
}
#>
