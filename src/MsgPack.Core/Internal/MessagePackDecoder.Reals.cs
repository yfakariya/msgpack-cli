// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class MessagePackDecoder
	{
		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Single DecodeSingle(in SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryPeek(source, out var header))
			{
				requestHint = 1;
				return default;
			}

			requestHint = 0;

			if (header < 128 || header >= 0xE0)
			{
				source.Advance(1);
				return header;
			}

			ParseNumberHeader(header, source, typeof(Single), out var length, out var kind);

			Single value;
			switch (kind)
			{
				case NumberKind.Signed:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadSByte(source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<short>(source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<int>(source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<long>(source, offset: 1, out requestHint);
							break;
						}
					}

					break;
				}
				case NumberKind.Unsigned:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadByte(source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<ushort>(source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<uint>(source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<ulong>(source, offset: 1, out requestHint);
							break;
						}
					}

					break;
				}
				case NumberKind.Single:
				{
					value = ReadValue<float>(source, offset: 1, out requestHint);
					break;
				}
				default:
				{
					// Double
					value = (Single)ReadValue<double>(source, offset: 1, out requestHint);
					break;
				}
			}

			if (requestHint != 0)
			{
				return default;
			}

			return value;
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override Double DecodeDouble(in SequenceReader<byte> source, out int requestHint)
		{
			if (!this.TryPeek(source, out var header))
			{
				requestHint = 1;
				return default;
			}

			requestHint = 0;

			if (header < 128 || header >= 0xE0)
			{
				source.Advance(1);
				return header;
			}

			ParseNumberHeader(header, source, typeof(Double), out var length, out var kind);

			Double value;
			switch (kind)
			{
				case NumberKind.Signed:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadSByte(source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<short>(source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<int>(source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<long>(source, offset: 1, out requestHint);
							break;
						}
					}

					break;
				}
				case NumberKind.Unsigned:
				{
					switch (length)
					{
						case 1:
						{
							value = ReadByte(source, offset: 1, out requestHint);
							break;
						}
						case 2:
						{
							value = ReadValue<ushort>(source, offset: 1, out requestHint);
							break;
						}
						case 4:
						{
							value = ReadValue<uint>(source, offset: 1, out requestHint);
							break;
						}
						default: 
						{
							Debug.Assert(length == 8, $"length({length}) != 8");
							value = ReadValue<ulong>(source, offset: 1, out requestHint);
							break;
						}
					}

					break;
				}
				case NumberKind.Single:
				{
					value = ReadValue<float>(source, offset: 1, out requestHint);
					break;
				}
				default:
				{
					// Double
					value = ReadValue<double>(source, offset: 1, out requestHint);
					break;
				}
			}

			if (requestHint != 0)
			{
				return default;
			}

			return value;
		}

	}
}
