// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Buffers.Text;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using MsgPack.Internal;

namespace MsgPack.Json
{
	partial class JsonDecoder
	{

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override string? DecodeNullableString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeStringCore(ref source, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override string? DecodeString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			return this.DecodeStringCore(ref source, out requestHint, cancellationToken);
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private string? DecodeStringCore(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			var startOffset = source.Consumed;

			var quotation = this.ReadStringStart(ref source, out requestHint);
			if (requestHint != 0)
			{
				return default;
			}

			// fast-path
			if (!source.TryReadTo(out ReadOnlySequence<byte> sequence, quotation, (byte)'\\', advancePastDelimiter: false) || !source.TryRead(out var delimiter))
			{
				// EoF
				requestHint = 1;
				source.Rewind(source.Consumed - startOffset);
				return default;
			}

			if (sequence.Length > this.Options.MaxStringLengthInBytes)
			{
				Throw.StringLengthExceeded(source.Consumed - sequence.Length, sequence.Length, this.Options.MaxBinaryLengthInBytes);
			}

			if (delimiter == quotation)
			{
				return Encoding.UTF8.GetString(sequence);
			}

			return this.DecodeStringCoreSlow(ref source, out requestHint, startOffset, quotation, ref sequence, delimiter, cancellationToken);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private string? DecodeStringCoreSlow(ref SequenceReader<byte> source, out int requestHint, long startOffset, byte quotation, ref ReadOnlySequence<byte> sequence, byte delimiter, CancellationToken cancellationToken)
		{
			var length = sequence.Length;
			using (var result = new StringBuilderBufferWriter(new StringBuilder(), this.Options))
			{
				Encoding.UTF8.GetChars(sequence, result);
				length += (int)sequence.Length;

				// We accept unescaped charactors except quotation even if the value is '\0' because we can handle them correctly.
				while (true)
				{
					// Decode escape sequence
					if (source.End)
					{
						// EoF
						requestHint = 2;
						break;
					}

					if (!source.IsNext((byte)'u', advancePast: true))
					{
						DecodeSpetialEscapeSequence(ref source, result);
						length += 2;
					}
					else
					{
						DecodeUnicodeEscapceSequence(ref source, result, out requestHint);
						if (requestHint != 0)
						{
							source.Rewind(source.Consumed - startOffset);
							return default;
						}

						length += 6;
					}

					cancellationToken.ThrowIfCancellationRequested();

					if (!source.TryReadTo(out sequence, quotation, (byte)'\\', advancePastDelimiter: false))
					{
						// EoF
						requestHint = 1;
						source.Rewind(source.Consumed - startOffset);
						break;
					}

					if (sequence.Length + length > this.Options.MaxStringLengthInBytes)
					{
						Throw.StringLengthExceeded(source.Consumed - sequence.Length, sequence.Length + length, this.Options.MaxBinaryLengthInBytes);
					}

					// Copy & UTF8 decoding existing.
					Encoding.UTF8.GetChars(sequence, result);
					length += (int)sequence.Length;

					// Handle delimiter
					source.TryRead(out delimiter);
					if (delimiter == quotation)
					{
						// End
						requestHint = 0;
						return result.ToString();
					}
				}
			}

			// No closing quotation.
			return default;
		}


		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int? DecodeNullableString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeStringCore(ref source, buffer, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int DecodeString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			return this.DecodeStringCore(ref source, buffer, out requestHint, cancellationToken);
		}

		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		private int DecodeStringCore(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			var startOffset = source.Consumed;

			var quotation = this.ReadStringStart(ref source, out requestHint);
			if (requestHint != 0)
			{
				return default;
			}

			// fast-path
			if (!source.TryReadTo(out ReadOnlySequence<byte> sequence, quotation, (byte)'\\', advancePastDelimiter: false) || !source.TryRead(out var delimiter))
			{
				// EoF
				requestHint = 1;
				source.Rewind(source.Consumed - startOffset);
				return default;
			}

			if (sequence.Length > this.Options.MaxStringLengthInBytes)
			{
				Throw.StringLengthExceeded(source.Consumed - sequence.Length, sequence.Length, this.Options.MaxBinaryLengthInBytes);
			}

			if (delimiter == quotation)
			{
				return Encoding.UTF8.GetChars(sequence, buffer);
			}

			return this.DecodeStringCoreSlow(ref source, buffer, out requestHint, startOffset, quotation, ref sequence, delimiter, cancellationToken);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private int DecodeStringCoreSlow(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, long startOffset, byte quotation, ref ReadOnlySequence<byte> sequence, byte delimiter, CancellationToken cancellationToken)
		{
			var length = sequence.Length;
			using (var result = new StringBuilderBufferWriter(new StringBuilder(), this.Options))
			{
				Encoding.UTF8.GetChars(sequence, result);
				length += (int)sequence.Length;

				// We accept unescaped charactors except quotation even if the value is '\0' because we can handle them correctly.
				while (true)
				{
					// Decode escape sequence
					if (source.End)
					{
						// EoF
						requestHint = 2;
						break;
					}

					if (!source.IsNext((byte)'u', advancePast: true))
					{
						DecodeSpetialEscapeSequence(ref source, result);
						length += 2;
					}
					else
					{
						DecodeUnicodeEscapceSequence(ref source, result, out requestHint);
						if (requestHint != 0)
						{
							source.Rewind(source.Consumed - startOffset);
							return default;
						}

						length += 6;
					}

					cancellationToken.ThrowIfCancellationRequested();

					if (!source.TryReadTo(out sequence, quotation, (byte)'\\', advancePastDelimiter: false))
					{
						// EoF
						requestHint = 1;
						source.Rewind(source.Consumed - startOffset);
						break;
					}

					if (sequence.Length + length > this.Options.MaxStringLengthInBytes)
					{
						Throw.StringLengthExceeded(source.Consumed - sequence.Length, sequence.Length + length, this.Options.MaxBinaryLengthInBytes);
					}

					// Copy & UTF8 decoding existing.
					Encoding.UTF8.GetChars(sequence, result);
					length += (int)sequence.Length;

					// Handle delimiter
					source.TryRead(out delimiter);
					if (delimiter == quotation)
					{
						// End
						requestHint = 0;
						return result.CopyTo(buffer);
					}
				}
			}

			// No closing quotation.
			return default;
		}


		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override byte[]? DecodeNullableBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeBinaryCore(ref source, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override byte[]? DecodeBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			return this.DecodeBinaryCore(ref source, out requestHint, cancellationToken);
		}

		private byte[]? DecodeBinaryCore(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default)
		{
			var startOffset = source.Consumed;

			var quotation = this.ReadStringStart(ref source, out requestHint);
			if (requestHint != 0)
			{
				return default;
			}

			if (!source.TryReadTo(out ReadOnlySequence<byte> sequence, quotation, advancePastDelimiter: true))
			{
				// EoF
				requestHint = 1;
				source.Rewind(source.Consumed - startOffset);
				return default;
			}

			if (sequence.Length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.BinaryLengthExceeded(startOffset + 1, sequence.Length, this.Options.MaxBinaryLengthInBytes);
			}

			var resultLength = 0;
			var inputBuffer = sequence.IsSingleSegment ? null : this.Options.ByteBufferPool.Rent(this.Options.MaxByteBufferLength);
			try
			{
				var outputBuffer = this.Options.ByteBufferPool.Rent(this.Options.MaxByteBufferLength);
				try
				{
					ReadOnlySpan<byte> inputSpan = sequence.FirstSpan;
					Span<byte> outputSpan = outputBuffer;
					var status = OperationStatus.DestinationTooSmall;
					var position = source.Consumed;
					while (true)
					{
						status = Base64.DecodeFromUtf8(inputSpan, outputSpan, out var bytesConsumed, out var bytesWritten, isFinalBlock: sequence.IsSingleSegment);
						inputSpan = inputSpan.Slice(bytesConsumed);
						outputSpan = outputSpan.Slice(bytesWritten);
						position += bytesConsumed;

						resultLength += bytesWritten;
						switch (status)
						{
							case OperationStatus.Done:
							{
								// OK
								var result = new byte[resultLength];
								unsafe
								{
									fixed (byte* pBuffer = outputBuffer)
									fixed (byte* pResult = result)
									{
										Buffer.MemoryCopy(pBuffer, pResult, result.Length, resultLength);
									}
								}

								return result;
							}
							case OperationStatus.DestinationTooSmall:
							{
								// Realloc buffer and set span head.

								var newBuffer = this.Options.ByteBufferPool.Rent(outputBuffer.Length * 2);
								unsafe
								{
									fixed (byte* pBuffer = outputBuffer)
									fixed (byte* pNewBuffer = newBuffer)
									{
										Buffer.MemoryCopy(pBuffer, pNewBuffer, outputBuffer.Length, outputBuffer.Length);
									}
								}

								outputSpan = newBuffer.AsSpan(outputBuffer.Length - outputSpan.Length);
								this.Options.ByteBufferPool.Return(outputBuffer, this.Options.ClearsBuffer);
								outputBuffer = newBuffer;
								break;
							}
							case OperationStatus.NeedMoreData:
							{
								// In this case, ReadOnlySequence<byte> is multi segment.
								Debug.Assert(!sequence.IsSingleSegment, "!sequence.IsSingleSegment");
								Debug.Assert(inputBuffer != null, "inputBuffer != null");

								// Realloc input span.

								var consumed = inputBuffer.Length - inputSpan.Length;

								sequence = sequence.Slice(consumed);
								var newInputSpanLength = (int)Math.Min(inputBuffer.Length, sequence.Length);
								sequence.Slice(0, newInputSpanLength).CopyTo(inputBuffer);
								inputSpan = inputBuffer.AsSpan(0, newInputSpanLength);
								break;
							}
							default:
							{
								Debug.Assert(status == OperationStatus.InvalidData, $"status ({status}) == OperationStatus.InvalidData");
								JsonThrow.InvalidBase64(position, Encoding.UTF8.GetString(inputSpan));
								// never
								return default;
							}
						}
					}
				}
				finally
				{
					this.Options.ByteBufferPool.Return(outputBuffer, this.Options.ClearsBuffer);
				}
			}
			finally
			{
				if (!(inputBuffer is null))
				{
					this.Options.ByteBufferPool.Return(inputBuffer, this.Options.ClearsBuffer);
				}
			}
		}


		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int? DecodeNullableBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			if (this.TryDecodeNull(ref source))
			{
				requestHint = 0;
				return null;
			}

			return this.DecodeBinaryCore(ref source, buffer, out requestHint, cancellationToken);
		}

		/// <inheritdoc />
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public sealed override int DecodeBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			this.ReadTrivia(ref source);
			return this.DecodeBinaryCore(ref source, buffer, out requestHint, cancellationToken);
		}

		private int DecodeBinaryCore(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default)
		{
			var startOffset = source.Consumed;

			var quotation = this.ReadStringStart(ref source, out requestHint);
			if (requestHint != 0)
			{
				return default;
			}

			if (!source.TryReadTo(out ReadOnlySequence<byte> sequence, quotation, advancePastDelimiter: true))
			{
				// EoF
				requestHint = 1;
				source.Rewind(source.Consumed - startOffset);
				return default;
			}

			if (sequence.Length > this.Options.MaxBinaryLengthInBytes)
			{
				Throw.BinaryLengthExceeded(startOffset + 1, sequence.Length, this.Options.MaxBinaryLengthInBytes);
			}

			var resultLength = 0;
			var inputBuffer = sequence.IsSingleSegment ? null : this.Options.ByteBufferPool.Rent(this.Options.MaxByteBufferLength);
			try
			{
				{
					ReadOnlySpan<byte> inputSpan = sequence.FirstSpan;
					Span<byte> outputSpan = buffer;
					var status = OperationStatus.DestinationTooSmall;
					var position = source.Consumed;
					while (true)
					{
						status = Base64.DecodeFromUtf8(inputSpan, outputSpan, out var bytesConsumed, out var bytesWritten, isFinalBlock: sequence.IsSingleSegment);
						inputSpan = inputSpan.Slice(bytesConsumed);
						outputSpan = outputSpan.Slice(bytesWritten);
						position += bytesConsumed;

						resultLength += bytesWritten;
						switch (status)
						{
							case OperationStatus.Done:
							{
								// OK
								return resultLength;
							}
							case OperationStatus.DestinationTooSmall:
							{
								Throw.TooSmallBuffer(nameof(buffer), Base64.GetMaxDecodedFromUtf8Length(((int)sequence.Length)));
								return default; // Never reaches
							}
							case OperationStatus.NeedMoreData:
							{
								// In this case, ReadOnlySequence<byte> is multi segment.
								Debug.Assert(!sequence.IsSingleSegment, "!sequence.IsSingleSegment");
								Debug.Assert(inputBuffer != null, "inputBuffer != null");

								// Realloc input span.

								var consumed = inputBuffer.Length - inputSpan.Length;

								sequence = sequence.Slice(consumed);
								var newInputSpanLength = (int)Math.Min(inputBuffer.Length, sequence.Length);
								sequence.Slice(0, newInputSpanLength).CopyTo(inputBuffer);
								inputSpan = inputBuffer.AsSpan(0, newInputSpanLength);
								break;
							}
							default:
							{
								Debug.Assert(status == OperationStatus.InvalidData, $"status ({status}) == OperationStatus.InvalidData");
								JsonThrow.InvalidBase64(position, Encoding.UTF8.GetString(inputSpan));
								// never
								return default;
							}
						}
					}
				}
			}
			finally
			{
				if (!(inputBuffer is null))
				{
					this.Options.ByteBufferPool.Return(inputBuffer, this.Options.ClearsBuffer);
				}
			}
		}

	}
}
