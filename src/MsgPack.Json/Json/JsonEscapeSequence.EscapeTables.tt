<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Runtime.InteropServices;

namespace MsgPack.Json
{
	partial class JsonEscapeSequence
	{
<#
foreach (var spec in
	new []
	{
		new { Label = "Base",							ExcludesTab = false,	ExcludesHtmlChars = true },
		new { Label = "BaseWithoutTab",					ExcludesTab = true,		ExcludesHtmlChars = true },
		new { Label = "BaseWithHtmlChars",				ExcludesTab = false,	ExcludesHtmlChars = false },
		new { Label = "BaseWithHtmlCharsWithoutTab",	ExcludesTab = true,		ExcludesHtmlChars = false },
	}
)
{
#>

		public static ReadOnlySpan<ulong> <#= spec.Label #>EscapeTable =>
			BitConverter.IsLittleEndian ?
				MemoryMarshal.Cast<byte, ulong>(<#= spec.Label #>EscapeTableLittleEndian) :
				MemoryMarshal.Cast<byte, ulong>(<#= spec.Label #>EscapeTableBigEndian);

		public static ReadOnlySpan<int> <#= spec.Label #>EscapeLengthTable =>
			BitConverter.IsLittleEndian ?
				MemoryMarshal.Cast<byte, int>(<#= spec.Label #>EscapeLengthTableLittleEndian) :
				MemoryMarshal.Cast<byte, int>(<#= spec.Label #>EscapeLengthTableBigEndian);

		public static ReadOnlySpan<byte> <#= spec.Label #>EscapeTableBigEndian =>
			new byte[]
			{
<#
	for (var i = 0; i < 0x80; i++)
	{
#>
				<#= Generate(i, spec.ExcludesTab, spec.ExcludesHtmlChars, forLittleEndian: false) #>,
<#
	}
#>
			};

		public static ReadOnlySpan<byte> <#= spec.Label #>EscapeTableLittleEndian =>
			new byte[]
			{
<#
	for (var i = 0; i < 0x80; i++)
	{
#>
				<#= Generate(i, spec.ExcludesTab, spec.ExcludesHtmlChars, forLittleEndian: true) #>,
<#
	}
#>
			};

		public static ReadOnlySpan<byte> <#= spec.Label #>EscapeLengthTableBigEndian =>
			new byte[]
			{
<#
	for (var i = 0; i < 0x80; i++)
	{
#>
				<#= GenerateLength(i, spec.ExcludesTab, spec.ExcludesHtmlChars, forLittleEndian: false) #>,
<#
	}
#>
			};

		public static ReadOnlySpan<byte> <#= spec.Label #>EscapeLengthTableLittleEndian =>
			new byte[]
			{
<#
	for (var i = 0; i < 0x80; i++)
	{
#>
				<#= GenerateLength(i, spec.ExcludesTab, spec.ExcludesHtmlChars, forLittleEndian: true) #>,
<#
	}
#>
			};
<#
}
#>
	}
}

<#+
string Generate(int codePoint, bool excludesTab, bool excludesHtmlChars, bool forLittleEndian)
{
	var bytes = GetEscapeSequenceBytes(codePoint, excludesTab, excludesHtmlChars);
	if (bytes.Length > 8)
	{
		throw new Exception($"U+{codePoint:X4} requires {bytes.Length} bytes.");
	}

	var span = new byte[8];
	bytes.CopyTo(span, 0);

	if (BitConverter.IsLittleEndian != forLittleEndian)
	{
		Array.Reverse(span);
	}

	var result = BitConverter.ToUInt64(span, 0);

	return $"{String.Join(", ", span.Select(b => $"0x{b:X2}"))}, // 0x{result:X16}";
}

string GenerateLength(int codePoint, bool excludesTab, bool excludesHtmlChars, bool forLittleEndian)
{
	var bytes = GetEscapeSequenceBytes(codePoint, excludesTab, excludesHtmlChars);
	var span = BitConverter.GetBytes(bytes.Length);

	if (BitConverter.IsLittleEndian != forLittleEndian)
	{
		Array.Reverse(span);
	}

	return $"{String.Join(", ", span.Select(b => $"0x{b:X2}"))}, // {bytes.Length} ({BitConverter.ToString(bytes)})";
}

byte[] GetEscapeSequenceBytes(int codePoint, bool excludesTab, bool excludesHtmlChars)
{
	if (codePoint < 0x20)
	{
		switch (codePoint)
		{
			case '\b':
			{
				return new [] { (byte)'\\', (byte)'b' };
			}
			case '\f':
			{
				return new [] { (byte)'\\', (byte)'f' };
			}
			case '\r':
			{
				return new [] { (byte)'\\', (byte)'r' };
			}
			case '\n':
			{
				return new [] { (byte)'\\', (byte)'n' };
			}
			case '\t':
			{
				if (excludesTab)
				{
					break;
				}

				return new [] { (byte)'\\', (byte)'t' };
			}
			default:
			{
				return GetUnicodeEscapeEquence(codePoint);
			}
		}
	}

	if (codePoint == '\\')
	{
		return new [] { (byte)'\\', (byte)'\\' };
	}

	if (!excludesHtmlChars)
	{
		switch(codePoint)
		{
			case '"':
			case '/':
			case '&':
			case '\'':
			case '<':
			case '>':
			{
				return GetUnicodeEscapeEquence(codePoint);
			}
		}
	}

	if (codePoint == '"')
	{
		return new [] { (byte)'\\', (byte)'"' };
	}

	if (codePoint == 0x7F)
	{
		return GetUnicodeEscapeEquence(codePoint);
	}

	return new [] { (byte)codePoint };
}

byte[] GetUnicodeEscapeEquence(int codePoint)
{
	var result = new byte[6];
	result[0] = (byte)'\\';
	result[1] = (byte)'u';
	result[2] = (byte)(codePoint >> 24 & 0xFF);
	result[3] = (byte)(codePoint >> 16 & 0xFF);
	result[4] = (byte)(codePoint >> 8 & 0xFF);
	result[5] = (byte)(codePoint & 0xFF);
	return result;
}
#>
