<#+
private void Write(
	string @namespace,
	string className,
	Action classDocFactory,
	string[] usingNamespaces,
	params Spec[] specs
)
{
#>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

#nullable enable

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Runtime.CompilerServices;
<#+
foreach (var usingNamespace in usingNamespaces)
{
#>
using <#= usingNamespace #>;
<#+
}
#>

namespace <#= @namespace #>
{
<#+
	classDocFactory();
#>
	public static partial class <#= className #>
	{
<#+
	foreach (var spec in specs)
	{
		WriteBody(spec);
	}
#>
		private static Type EnsureEnumType(Type targetType, [CallerArgumentExpression("targetType")] string? paramName = null)
		{
			if (!Ensure.NotNull(targetType).GetIsEnum())
			{
				ThrowIsNotEnumType(targetType, paramName);
			}

			return targetType;
		}

		private static Type EnsureEnumType<T>()
		{
			if (!typeof(T).GetIsEnum())
			{
				ThrowIsNotEnumType(typeof(T), null);
			}

			return typeof(T);
		}

		private static void ThrowIsNotEnumType(Type targetType, string? paramName)
		{
			var message = $"Type '{targetType}' is not enum type.";
			if (paramName == null)
			{
				throw new InvalidOperationException(message);
			}
			else
			{
				throw new ArgumentException(message, paramName);
			}
		}
	}
}
<#+
}

private sealed class Spec
{
	public string BaseTypeName { get; set; }
	public bool IsGeneric { get; set; }
	public string ProviderTypeName { get; set; }
	public string Codec { get; set; } = String.Empty;
	public bool IsObjectSerializer { get; set; }
	public bool UseDefaultCodecProvider => String.IsNullOrEmpty(this.Codec);
}

private void WriteBody(Spec spec)
{
	var genericParameter = spec.IsGeneric ? "<T>" : String.Empty;
	var codeTypeName = spec.IsGeneric ? $"{spec.BaseTypeName}<T>" : spec.BaseTypeName;
	var docTypeName = spec.IsGeneric ? $"{spec.BaseTypeName}{{T}}" : spec.BaseTypeName;
	var docTargetType = spec.IsGeneric ? "<typeparamref name=\"T\"/>" : "<paramref name=\"targetType\"/>";
	var typeParameter = spec.IsGeneric ? String.Empty : ", Type targetType"; 
	var typeArgument = spec.IsGeneric ? "typeof(T)" : "targetType"; 
	var codecProviderParameter =
		spec.IsObjectSerializer ?
			String.Empty :
			spec.UseDefaultCodecProvider ?
				", CodecProvider codecProvider" :
				$", {spec.Codec}CodecProvider? codecProvider = null"; 
	var codecProviderArgument =
		spec.IsObjectSerializer ?
			String.Empty :
			spec.UseDefaultCodecProvider ?
				", Ensure.NotNull(codecProvider)" :
				$", codecProvider ?? {spec.Codec}CodecProvider.Default";

	var typeParameterSuffix = "This type cannot be abstract type including interfaces.";
#>
		/// <summary>
		///		Gets the <see cref="<#= docTypeName #>"/> object for the specified type without any polymorphism.
		/// </summary>
<#+
	WriteTypeParameterDoc(spec, typeParameterSuffix);
#>
		/// <param name="provider">The <see cref="<#= spec.ProviderTypeName #>"/>.</param>
<#+
	WriteParametersDoc(spec, typeParameterSuffix);
#>
		/// <returns>The <see cref="<#= docTypeName #>"/> object for the specified type.</returns>
<#+
	WriteExceptionDoc(spec, "is abstract type and is not known collection interface");
#>
		public static <#= codeTypeName #> Get<#= spec.Codec #>Serializer<#= genericParameter #>(this <#= spec.ProviderTypeName #> provider<#= typeParameter #><#= codecProviderParameter #>)
			=> (Ensure.NotNull(provider).GetSerializer(<#= typeArgument #>, null<#= codecProviderArgument #>) as <#= codeTypeName #>)!;

<#+
	typeParameterSuffix = "This type can be abstract type including interfaces.";
#>
		/// <summary>
		///		Gets the polymorphic <see cref="<#= docTypeName #>"/> object for the specified type, and polymorphism schema defined by the member metadata.
		/// </summary>
<#+
	WriteTypeParameterDoc(spec, typeParameterSuffix);
#>
		/// <param name="provider">The <see cref="<#= spec.ProviderTypeName #>"/>.</param>
<#+
	WriteParametersDoc(spec, typeParameterSuffix);
#>
		/// <param name="schema">The <see cref="PolymorphismSchema"/> to tell polymoprhism related information to the underlying serializer provider. This value is defined by the member metadata.. This parameer is optional.</param>
		/// <returns>The <see cref="<#= docTypeName #>"/> object for the specified type.</returns>
<#+
	WriteExceptionDoc(spec, typeSpec: null);
#>
		/// <remarks>
		///		When <paramref name="schema"/> is <c>null</c>, this method is identical to <see cref="Get<#= spec.Codec #>Serializer{T}(<#= spec.ProviderTypeName #>)"/>.
		/// </remarks>
		public static <#= codeTypeName #> GetPolymorphic<#= spec.Codec #>Serializer<#= genericParameter #>(this <#= spec.ProviderTypeName#> provider<#= typeParameter #><#= codecProviderParameter #>, PolymorphismSchema? schema = null)
			=> (Ensure.NotNull(provider).GetSerializer(<#= typeArgument #>, schema ?? PolymorphismSchema.Default<#= codecProviderArgument #>) as <#= codeTypeName #>)!;

<#+
	typeParameterSuffix = "This type must be enum type.";
	var enumTypeArgument = spec.IsGeneric ? "EnsureEnumType<T>()" : "EnsureEnumType(targetType)";
#>
		/// <summary>
		///		Gets the <see cref="<#= docTypeName #>"/> object for the specified enum type, and enum serialization method defined by the member metadata.
		/// </summary>
<#+
	WriteTypeParameterDoc(spec, typeParameterSuffix);
#>
		/// <param name="provider">The <see cref="<#= spec.ProviderTypeName #>"/>.</param>
<#+
	WriteParametersDoc(spec, typeParameterSuffix);
#>
		/// <param name="defaultEnumSerializationMethod">The <see cref="EnumSerializationMethod"/> to tell enum serialization method to the underlying serializer provider. This value is defined by the member metadata. This parameer is optional.</param>
		/// <returns>The <see cref="<#= docTypeName #>"/> object for the specified type.</returns>
<#+
	WriteExceptionDoc(spec, typeSpec: "is not enum type");
#>
		/// <remarks>
		///		When <paramref name="defaultEnumSerializationMethod"/> is <c>null</c>, the default value which was configured in <see cref="EnumSerializationOptionsBuilder"/> or the underlying codec is used.
		/// </remarks>
		public static <#= codeTypeName #> GetEnum<#= spec.Codec #>Serializer<#= genericParameter #>(this <#= spec.ProviderTypeName #> provider<#= typeParameter #><#= codecProviderParameter #>, EnumSerializationMethod? defaultEnumSerializationMethod = null)
	<#+
		if (spec.IsGeneric)
		{
	#>
			where T : Enum
	<#+
		}
	#>
			=> (Ensure.NotNull(provider).GetSerializer(<#= enumTypeArgument #>, BoxedEnumSerializationMethod.Get(defaultEnumSerializationMethod)<#= codecProviderArgument #>) as <#= codeTypeName #>)!;

<#+
	typeParameterSuffix = "This type should be one of the well known date time like types.";
#>
		/// <summary>
		///		Gets the <see cref="<#= docTypeName #>"/> object for the specified date time like type, and date time conversion method defined by the member metadata.
		/// </summary>
<#+
	WriteTypeParameterDoc(spec, typeParameterSuffix);
#>
		/// <param name="provider">The <see cref="<#= spec.ProviderTypeName #>"/>.</param>
<#+
	WriteParametersDoc(spec, typeParameterSuffix);
#>
		/// <param name="defaultDateTimeConversionMethod">The <see cref="DateTimeConversionMethod"/> to tell date time conversion method to the underlying serializer provider. This value is defined by the member metadata. This parameter is optional.</param>
		/// <returns>The <see cref="<#= docTypeName #>"/> object for the specified type.</returns>
<#+
	WriteExceptionDoc(spec, typeSpec: null);
#>
		/// <remarks>
		///		When <paramref name="defaultDateTimeConversionMethod"/> is <c>null</c>, the default value which was configured in <see cref="DateTimeSerializationOptionsBuilder"/> or the underlying codec is used.
		///		The following types are considered as date time like types and their <see cref="Nullable{T}"/> by default:
		///		<list type="bullet">
		///			<item><see cref="DateTime"/></item>
		///			<item><see cref="DateTimeOffset"/></item>
		///			<item><see cref="Timestamp"/></item>
		///			<item><see cref="System.Runtime.InteropServices.ComTypes.FILETIME"/></item>
		///		</list>
		/// </remarks>
		public static <#= codeTypeName #> GetDateTime<#= spec.Codec #>Serializer<#= genericParameter #>(this <#= spec.ProviderTypeName #> provider<#= typeParameter #><#= codecProviderParameter #>, DateTimeConversionMethod? defaultDateTimeConversionMethod = null)
			=> (Ensure.NotNull(provider).GetSerializer(<#= typeArgument #>, BoxedDateTimeConversionMethod.Get(defaultDateTimeConversionMethod)<#= codecProviderArgument #>) as <#= codeTypeName #>)!;

<#+
}

private void WriteTypeParameterDoc(Spec spec, string typeParameterSuffix)
{
	if (spec.IsGeneric)
	{
#>
		/// <typeparam name="T">The target type of the serializer. <#= typeParameterSuffix #></typeparam>
<#+
	}
}

private void WriteParametersDoc(Spec spec, string typeParameterSuffix)
{
	if (!spec.IsGeneric)
	{
#>
		/// <param name="targetType">The target type of the serializer. <#= typeParameterSuffix #></param>
<#+
	}

	if (!spec.IsObjectSerializer)
	{
#>
		/// <param name="codecProvider">The <see cref="CodecProvider" /> to get <see cref="FormatEncoder" /> and <see cref="FormatDecoder" />.</param>
<#+
	}
}

private void WriteExceptionDoc(Spec spec, string? typeSpec)
{
#>
		/// <exception cref="ArgumentNullException">
		///		<paramref name="provider" /> is <c>null</c>.
<#+
	if (!spec.IsGeneric)
	{
#>
		///		Or, <paramref name="targetType" /> is <c>null</c>.
<#+
	}

	if (spec.UseDefaultCodecProvider && !spec.IsObjectSerializer)
	{
#>
		///		Or, <paramref name="codecProvider" /> is <c>null</c>.
<#+
	}

#>
		///	</exception>
<#+
	if (typeSpec == null)
	{
		return;
	}

	if (spec.IsGeneric)
	{
#>
		/// <exception cref="InvalidOperationException">
		///		<typeparamref name="T" /> <#= typeSpec #>.
		/// </exception>
<#+
	}
	else
	{
#>
		/// <exception cref="ArgumentException">
		///		<paramref name="targetType" /> <#= typeSpec #>.
		/// </exception>
<#+
	}
}
#>
