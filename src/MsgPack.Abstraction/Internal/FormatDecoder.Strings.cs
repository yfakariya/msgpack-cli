// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace MsgPack.Internal
{
	partial class FormatDecoder
	{
		/// <summary>
		///		Decodes <see cref="String" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public String DecodeString(ref SequenceReader<byte> source, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeString(ref source, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForString(source.Consumed, typeof(String), encoding, requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes <see cref="String" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		public abstract String? DecodeString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes <see cref="String" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public String? DecodeNullableString(ref SequenceReader<byte> source, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableString(ref source, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForString(source.Consumed, typeof(String), encoding, requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="String" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract String? DecodeNullableString(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Span{T}" /> of <see cref="Char" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Char" /> which will store the decoded binary.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int DecodeString(ref SequenceReader<byte> source, Span<char> buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeString(ref source, buffer, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForString(source.Consumed, typeof(String), encoding, requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Span{T}" /> of <see cref="Char" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Char" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		public abstract int DecodeString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Span{T}" /> of <see cref="Char" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Char" /> which will store the decoded binary.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int? DecodeNullableString(ref SequenceReader<byte> source, Span<char> buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableString(ref source, buffer, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForString(source.Consumed, typeof(String), encoding, requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Span{T}" /> of <see cref="Char" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Char" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="String" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract int? DecodeNullableString(ref SequenceReader<byte> source, Span<char> buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);


#if FEATURE_UTF8STRING

		/// <summary>
		///		Decodes <see cref="Utf8String" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Utf8String DecodeUtf8String(ref SequenceReader<byte> source, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeUtf8String(ref source, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForUtf8String(source.Consumed, typeof(Utf8String), encoding, requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes <see cref="Utf8String" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		public abstract Utf8String? DecodeUtf8String(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes <see cref="Utf8String" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Utf8String? DecodeNullableUtf8String(ref SequenceReader<byte> source, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableUtf8String(ref source, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForUtf8String(source.Consumed, typeof(Utf8String), encoding, requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Utf8String" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Utf8String? DecodeNullableUtf8String(ref SequenceReader<byte> source, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Utf8Span" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Utf8Span" /> which will store the decoded binary.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int DecodeUtf8String(ref SequenceReader<byte> source, Utf8Span buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeUtf8String(ref source, buffer, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForUtf8String(source.Consumed, typeof(Utf8String), encoding, requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Utf8Span" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Utf8Span" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		public abstract int DecodeUtf8String(ref SequenceReader<byte> source, Utf8Span buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Utf8Span" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Utf8Span" /> which will store the decoded binary.</param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int? DecodeNullableUtf8String(ref SequenceReader<byte> source, Utf8Span buffer, Encoding? encoding = null, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableUtf8String(ref source, buffer, out var requestHint, encoding, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInputForUtf8String(source.Consumed, typeof(Utf8String), encoding, requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Utf8Span" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Utf8Span" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="encoding">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Utf8String" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract int? DecodeNullableUtf8String(ref SequenceReader<byte> source, Utf8Span buffer, out int requestHint, Encoding? encoding = null, CancellationToken cancellationToken = default);


#endif // FEATURE_UTF8STRING

		/// <summary>
		///		Decodes <see cref="byte[]" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public byte[] DecodeBinary(ref SequenceReader<byte> source, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeBinary(ref source, out var requestHint, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(byte[]), requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes <see cref="byte[]" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		public abstract byte[]? DecodeBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes <see cref="byte[]" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public byte[]? DecodeNullableBinary(ref SequenceReader<byte> source, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableBinary(ref source, out var requestHint, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(byte[]), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="byte[]" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract byte[]? DecodeNullableBinary(ref SequenceReader<byte> source, out int requestHint, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Span{T}" /> of <see cref="Byte" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Byte" /> which will store the decoded binary.</param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int DecodeBinary(ref SequenceReader<byte> source, Span<byte> buffer, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeBinary(ref source, buffer, out var requestHint, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(byte[]), requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes the value from specified sequence to <see cref="Span{T}" /> of <see cref="Byte" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Byte" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		The length of the decoded value.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		public abstract int DecodeBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Span{T}" /> of <see cref="Byte" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Byte" /> which will store the decoded binary.</param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public int? DecodeNullableBinary(ref SequenceReader<byte> source, Span<byte> buffer, CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullableBinary(ref source, buffer, out var requestHint, cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(byte[]), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes the value or <c>null</c> from specified sequence to <see cref="Span{T}" /> of <see cref="Byte" />.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="buffer"><see cref="Span{T}" /> of <see cref="Byte" /> which will store the decoded binary.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		The length of the decoded value;
		///		<c>null</c> when the underlying value is <c>null</c>.
		///		This value can be <c>0</c> for empty string.
		///		Note that the value of this return is not defined when <paramref name="requestHint" /> is <c>0</c>. 
		/// </return>
		/// <exception cref="MessageFormatException"><paramref name="source"/> contains valid byte sequence for the underlying format.</exception>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="byte[]" /> type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract int? DecodeNullableBinary(ref SequenceReader<byte> source, Span<byte> buffer, out int requestHint, CancellationToken cancellationToken = default);

	}
}
