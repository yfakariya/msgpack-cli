<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

#nullable enable

using System;
using System.Buffers;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;

namespace MsgPack.Internal
{
	partial class FormatDecoder
	{
<#
foreach (var spec in new [] {
	new
	{
		Name = "String", Type = "String", ThrowSuffix = "ForString",
		ExtraParameters = "Encoding? encoding = null, ",
		ExtraParameterDocs = new [] { "<param name=\"encoding\">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>" },
		ExtraArguments = "encoding, ", IfDef = String.Empty
	},
	new
	{
		Name = "Utf8String", Type = "Utf8String", ThrowSuffix = "ForUtf8String",
		ExtraParameters = "Encoding? encoding = null, ",
		ExtraParameterDocs = new [] { "<param name=\"encoding\">Specify charactor encoding. This value can be omitted, and default is UTF-8 without BOM.</param>" },
		ExtraArguments = "encoding, ", IfDef = "FEATURE_UTF8STRING"
	},
	new
	{
		Name = "Binary", Type = "byte[]", ThrowSuffix = String.Empty,
		ExtraParameters = String.Empty,
		ExtraParameterDocs = Array.Empty<string>(),
		ExtraArguments = String.Empty, IfDef = String.Empty
	},
})
{
	if (!String.IsNullOrEmpty(spec.IfDef))
	{
#>

#if <#= spec.IfDef #>

<#
	}
#>
		/// <summary>
		///		Decodes <see cref="<#= spec.Type #>" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
<#
	foreach (var doc in spec.ExtraParameterDocs)
	{
#>
		/// <#= doc #>
<#
	}
#>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="<#= spec.Type #>" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public <#= spec.Type #> Decode<#= spec.Name #>(ref SequenceReader<byte> source, <#= spec.ExtraParameters #>CancellationToken cancellationToken = default)
		{
			var result = this.Decode<#= spec.Name #>(ref source, out var requestHint, <#= spec.ExtraArguments #>cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput<#= spec.ThrowSuffix #>(source.Consumed, typeof(<#= spec.Type #>), <#= spec.ExtraArguments #>requestHint);
			}

			return result!;
		}

		/// <summary>
		///		Decodes <see cref="<#= spec.Type #>" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
<#
	foreach (var doc in spec.ExtraParameterDocs)
	{
#>
		/// <#= doc #>
<#
	}
#>
		/// <param name="cacellationToken"><see cref="CancellationToken" /> to cancel long running operation. This value can be omitted.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="<#= spec.Type #>" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract <#= spec.Type #>? Decode<#= spec.Name #>(ref SequenceReader<byte> source, out int requestHint, <#= spec.ExtraParameters #>CancellationToken cancellationToken = default);

		/// <summary>
		///		Decodes <see cref="<#= spec.Type #>" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
<#
	foreach (var doc in spec.ExtraParameterDocs)
	{
#>
		/// <#= doc #>
<#
	}
#>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="<#= spec.Type #>" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public <#= spec.Type #>? DecodeNullable<#= spec.Name #>(ref SequenceReader<byte> source, <#= spec.ExtraParameters #>CancellationToken cancellationToken = default)
		{
			var result = this.DecodeNullable<#= spec.Name #>(ref source, out var requestHint, <#= spec.ExtraArguments #>cancellationToken);
			if (requestHint != 0)
			{
				Throw.InsufficientInput<#= spec.ThrowSuffix #>(source.Consumed, typeof(<#= spec.Type #>), <#= spec.ExtraArguments #>requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="<#= spec.Type #>" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
<#
	foreach (var doc in spec.ExtraParameterDocs)
	{
#>
		/// <#= doc #>
<#
	}
#>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="<#= spec.Type #>" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract <#= spec.Type #>? DecodeNullable<#= spec.Name #>(ref SequenceReader<byte> source, out int requestHint, <#= spec.ExtraParameters #>CancellationToken cancellationToken = default);

<#
	if (!String.IsNullOrEmpty(spec.IfDef))
	{
#>

#endif // <#= spec.IfDef #>

<#
	}
}
#>
	}
}
