// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.

using System;
using System.Buffers;
using System.Runtime.CompilerServices;

namespace MsgPack.Internal
{
	partial class Decoder<TExtensionType>
	{
		/// <summary>
		///		Decodes <see cref="Byte" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Byte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Byte DecodeByte(ref SequenceReader<byte> source)
		{
			var result = this.DecodeByte(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Byte), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Byte" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Byte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Byte DecodeByte(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Byte" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Byte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Byte? DecodeNullableByte(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableByte(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Byte), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Byte" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Byte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Byte? DecodeNullableByte(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Int16" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int16 DecodeInt16(ref SequenceReader<byte> source)
		{
			var result = this.DecodeInt16(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int16), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Int16" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Int16 DecodeInt16(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Int16" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int16? DecodeNullableInt16(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableInt16(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int16), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Int16" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Int16? DecodeNullableInt16(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Int32" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int32 DecodeInt32(ref SequenceReader<byte> source)
		{
			var result = this.DecodeInt32(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int32), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Int32" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Int32 DecodeInt32(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Int32" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int32? DecodeNullableInt32(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableInt32(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int32), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Int32" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Int32? DecodeNullableInt32(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Int64" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int64 DecodeInt64(ref SequenceReader<byte> source)
		{
			var result = this.DecodeInt64(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int64), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Int64" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Int64 DecodeInt64(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Int64" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Int64? DecodeNullableInt64(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableInt64(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Int64), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Int64" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Int64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Int64? DecodeNullableInt64(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="SByte" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="SByte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public SByte DecodeSByte(ref SequenceReader<byte> source)
		{
			var result = this.DecodeSByte(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(SByte), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="SByte" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="SByte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract SByte DecodeSByte(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="SByte" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="SByte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public SByte? DecodeNullableSByte(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableSByte(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(SByte), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="SByte" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="SByte" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract SByte? DecodeNullableSByte(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="UInt16" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt16 DecodeUInt16(ref SequenceReader<byte> source)
		{
			var result = this.DecodeUInt16(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt16), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="UInt16" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract UInt16 DecodeUInt16(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="UInt16" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt16? DecodeNullableUInt16(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableUInt16(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt16), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="UInt16" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt16" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract UInt16? DecodeNullableUInt16(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="UInt32" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt32 DecodeUInt32(ref SequenceReader<byte> source)
		{
			var result = this.DecodeUInt32(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt32), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="UInt32" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract UInt32 DecodeUInt32(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="UInt32" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt32? DecodeNullableUInt32(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableUInt32(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt32), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="UInt32" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt32" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract UInt32? DecodeNullableUInt32(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="UInt64" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt64 DecodeUInt64(ref SequenceReader<byte> source)
		{
			var result = this.DecodeUInt64(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt64), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="UInt64" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract UInt64 DecodeUInt64(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="UInt64" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public UInt64? DecodeNullableUInt64(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableUInt64(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(UInt64), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="UInt64" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="UInt64" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract UInt64? DecodeNullableUInt64(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Single" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Single" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Single DecodeSingle(ref SequenceReader<byte> source)
		{
			var result = this.DecodeSingle(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Single), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Single" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Single" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Single DecodeSingle(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Single" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Single" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Single? DecodeNullableSingle(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableSingle(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Single), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Single" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Single" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Single? DecodeNullableSingle(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Double" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Double" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Double DecodeDouble(ref SequenceReader<byte> source)
		{
			var result = this.DecodeDouble(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Double), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Double" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Double" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Double DecodeDouble(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Double" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Double" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Double? DecodeNullableDouble(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableDouble(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Double), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Double" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Double" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Double? DecodeNullableDouble(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Decodes <see cref="Boolean" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Boolean" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Boolean DecodeBoolean(ref SequenceReader<byte> source)
		{
			var result = this.DecodeBoolean(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Boolean), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Decodes <see cref="Boolean" /> value from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Boolean" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		public abstract Boolean DecodeBoolean(ref SequenceReader<byte> source, out int requestHint);

		/// <summary>
		///		Encodes <see cref="Boolean" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Boolean" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		///	<exception cref="InsufficientInputException"><paramref name="source"/> does not contain enough bytes to decode.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public Boolean? DecodeNullableBoolean(ref SequenceReader<byte> source)
		{
			var result = this.DecodeNullableBoolean(ref source, out var requestHint);
			if (requestHint != 0)
			{
				Throw.InsufficientInput(source.Consumed, typeof(Boolean), requestHint);
			}

			return result;
		}

		/// <summary>
		///		Encodes <see cref="Boolean" /> value or <c>null</c> from specified sequence.
		/// </summary>
		/// <param name="source"><see cref="SequenceReader{T}">SequenceReader&lt;byte&gt;</see>.</param>
		/// <param name="requestHint">
		///		<c>0</c> if this method succeeds to decode value; Positive integer when <paramref name="source" /> does not contain enough bytes to decode, and required memory bytes hint is stored.
		///		Note that <c>-1</c> represents unknown size. If so, caller must supply new buffer with most efficient size.
		/// </param>
		/// <return>
		///		Decoded value if this method succeeds to decode value; Default value when <paramref name="source" /> does not contain enough bytes to decode.
		///		If this value is default, <paramref name="source" /> will not be advanced.
		/// </return>
		/// <remarks>
		///		The caller must concatinate old remaining sequence and new sequence when this method returns <c>false</c> and then recall.
		/// </remarks>
		/// <exception cref="MessageTypeException">The underlying format value is not compatible to <see cref="Boolean" /> type.</exception>
		/// <exception cref="NotSupportedException">The underlying format does not suppor this type.</exception>
		[MethodImpl(MethodImplOptionsShim.AggressiveInlining)]
		public abstract Boolean? DecodeNullableBoolean(ref SequenceReader<byte> source, out int requestHint);

	}
}
