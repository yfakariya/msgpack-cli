// Copyright (c) FUJIWARA, Yusuke and all contributors.
// This file is licensed under Apache2 license.
// See the LICENSE in the project root for more information.

#nullable enable

// <auto-generated /> 
// This file is generated from acompanying .tt file.
// DO NOT edit this file directly, edit .tt file instead.


using System;
using System.Buffers;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MsgPack
{
	/// <summary>
	///		Represents deserialized object of MsgPack.
	/// </summary>
	[StructLayout(LayoutKind.Auto)]
	public partial struct MessagePackObject : IEquatable<MessagePackObject>
	{
		#region -- Constructors --
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Boolean"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Boolean value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value ? (ulong)1 : 0;
			this._handleOrTypeCode = BooleanTypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Byte"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Byte value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value;
			this._handleOrTypeCode = ByteTypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="SByte"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		[CLSCompliant(false)]
		public MessagePackObject(SByte value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)value);
			this._handleOrTypeCode = SByteTypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Int16"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Int16 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)value);
			this._handleOrTypeCode = Int16TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="UInt16"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		[CLSCompliant(false)]
		public MessagePackObject(UInt16 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value;
			this._handleOrTypeCode = UInt16TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Int32"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Int32 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)value);
			this._handleOrTypeCode = Int32TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="UInt32"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		[CLSCompliant(false)]
		public MessagePackObject(UInt32 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value;
			this._handleOrTypeCode = UInt32TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Int64"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Int64 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)value);
			this._handleOrTypeCode = Int64TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="UInt64"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		[CLSCompliant(false)]
		public MessagePackObject(UInt64 value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value;
			this._handleOrTypeCode = UInt64TypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Single"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Single value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)Binary.ToBits(value));
			this._handleOrTypeCode = SingleTypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="Double"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(Double value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)BitConverter.DoubleToInt64Bits(value));
			this._handleOrTypeCode = DoubleTypeCode;
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <remarks>
		///		This constructor invokes <see cref="MessagePackObject(Byte[],Boolean)" /> with <c>false</c>, that means if you pass tha bytes array which is valid utf-8, resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(String value)
			: this(value, false) { }

		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <param name="isBinary"><c>true</c> if <paramref name="value"/> always should be binary; <c>false</c>, otherwise.</param>
		/// <remarks>
		///		When the <paramref name="isBinary" /> is <c>true</c>, then resulting object represents binary even if the <paramref name="value"/> is valid utf-8 sequence,
		///		that is, its <see cref="UnderlyingType" /> should be <see cref="Byte" />[].
		///		On the other hand, when  contrast, the <paramref name="isBinary" /> is <c>false</c>, and if the <paramref name="value"/> is valid utf-8, 
		///		then the resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(String value, bool isBinary)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			if (value == null)
			{
				this._handleOrTypeCode = null;
			}
			else
			{
				this._handleOrTypeCode = new MessagePackString(value);
			}
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <remarks>
		///		This constructor invokes <see cref="MessagePackObject(Byte[],Boolean)" /> with <c>false</c>, that means if you pass tha bytes array which is valid utf-8, resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(Byte[] value)
			: this(value, false) { }

		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <param name="isBinary"><c>true</c> if <paramref name="value"/> always should be binary; <c>false</c>, otherwise.</param>
		/// <remarks>
		///		When the <paramref name="isBinary" /> is <c>true</c>, then resulting object represents binary even if the <paramref name="value"/> is valid utf-8 sequence,
		///		that is, its <see cref="UnderlyingType" /> should be <see cref="Byte" />[].
		///		On the other hand, when  contrast, the <paramref name="isBinary" /> is <c>false</c>, and if the <paramref name="value"/> is valid utf-8, 
		///		then the resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(Byte[] value, bool isBinary)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			if (value == null)
			{
				this._handleOrTypeCode = null;
			}
			else
			{
				this._handleOrTypeCode = new MessagePackString(value, isBinary);
			}
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <remarks>
		///		This constructor invokes <see cref="MessagePackObject(Byte[],Boolean)" /> with <c>false</c>, that means if you pass tha bytes array which is valid utf-8, resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(ReadOnlyMemory<byte> value)
			: this(value, false) { }

		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <param name="isBinary"><c>true</c> if <paramref name="value"/> always should be binary; <c>false</c>, otherwise.</param>
		/// <remarks>
		///		When the <paramref name="isBinary" /> is <c>true</c>, then resulting object represents binary even if the <paramref name="value"/> is valid utf-8 sequence,
		///		that is, its <see cref="UnderlyingType" /> should be <see cref="Byte" />[].
		///		On the other hand, when  contrast, the <paramref name="isBinary" /> is <c>false</c>, and if the <paramref name="value"/> is valid utf-8, 
		///		then the resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(ReadOnlyMemory<byte> value, bool isBinary)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._handleOrTypeCode = new MessagePackString(value, false);
		}
		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <remarks>
		///		This constructor invokes <see cref="MessagePackObject(Byte[],Boolean)" /> with <c>false</c>, that means if you pass tha bytes array which is valid utf-8, resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(ReadOnlyMemory<char> value)
			: this(value, false) { }

		/// <summary>
		///		Initializes a new instance of the <see cref="Byte"/>[] type which wraps <see cref="Byte" />[] instance with specified manner.
		/// </summary>
		/// <param name="value">A bytes array to be wrapped.</param>
		/// <param name="isBinary"><c>true</c> if <paramref name="value"/> always should be binary; <c>false</c>, otherwise.</param>
		/// <remarks>
		///		When the <paramref name="isBinary" /> is <c>true</c>, then resulting object represents binary even if the <paramref name="value"/> is valid utf-8 sequence,
		///		that is, its <see cref="UnderlyingType" /> should be <see cref="Byte" />[].
		///		On the other hand, when  contrast, the <paramref name="isBinary" /> is <c>false</c>, and if the <paramref name="value"/> is valid utf-8, 
		///		then the resulting object can be <see cref="String" />,
		///		and its <see cref="UnderlyingType" /> should be <see cref="String" />.
		/// </remarks>
		public MessagePackObject(ReadOnlyMemory<char> value, bool isBinary)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._handleOrTypeCode = new MessagePackString(value);
		}

#pragma warning disable 0618 // obsolete
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="MessagePackExtendedTypeObject"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(MessagePackExtendedTypeObject value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = value.TypeCode;
			this._handleOrTypeCode = value.Body;
		}

#pragma warning restore 0618 // obsolete
		/// <summary>
		///		Initializes a new instance of the <see cref="MessagePackObject"/> type which wraps <see cref="ExtensionTypeObject"/> instance.
		/// </summary>
		/// <param name="value">A <see cref="MessagePackObject"/> value to be wrapped.</param>
		public MessagePackObject(ExtensionTypeObject value)
		{
			// trick: Avoid long boilerplate initialization.
			this = new MessagePackObject();
			this._value = unchecked((ulong)value.Type.Tag);
			this._handleOrTypeCode = value.Body;
		}

		#endregion -- Constructors --

		#region -- Primitive Type Conversion Methods --

		/// <summary>
		///		Convert this instance to <see cref="Boolean" /> instance.
		/// </summary>
		/// <returns><see cref="Boolean" /> instance corresponds to this instance.</returns>
		public Boolean AsBoolean()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Boolean>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null || typeCode.TypeCode != MessagePackValueTypeCode.Boolean)
			{
				ThrowInvalidTypeAs<bool>(this);
			}

			Debug.Assert(typeCode != null);
			
			return this._value != 0;
		}

		/// <summary>
		///		Convert this instance to <see cref="Byte" /> instance.
		/// </summary>
		/// <returns><see cref="Byte" /> instance corresponds to this instance.</returns>
		public Byte AsByte()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Byte>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Byte>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Byte.MinValue;
					const long maxValue = (long)Byte.MaxValue;
					
					long asInt64 = unchecked((long)this._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Byte>(this);
					}

					return unchecked((Byte)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Byte.MaxValue);
					if(maxValue < this._value)
					{
						ThrowInvalidTypeAs<Byte>(this);
					}
					
					return (Byte)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Byte)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Byte)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<Byte>(this);
				return default(Byte); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="SByte" /> instance.
		/// </summary>
		/// <returns><see cref="SByte" /> instance corresponds to this instance.</returns>
		[CLSCompliant(false)]
		public SByte AsSByte()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<SByte>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<SByte>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)SByte.MinValue;
					const long maxValue = (long)SByte.MaxValue;
					
					long asInt64 = unchecked((long)this._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<SByte>(this);
					}

					return unchecked((SByte)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)SByte.MaxValue);
					if(maxValue < this._value)
					{
						ThrowInvalidTypeAs<SByte>(this);
					}
					
					return (SByte)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (SByte)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (SByte)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<SByte>(this);
				return default(SByte); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int16" /> instance.
		/// </summary>
		/// <returns><see cref="Int16" /> instance corresponds to this instance.</returns>
		public Int16 AsInt16()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Int16>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int16>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Int16.MinValue;
					const long maxValue = (long)Int16.MaxValue;
					
					long asInt64 = unchecked((long)this._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Int16>(this);
					}

					return unchecked((Int16)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int16.MaxValue);
					if(maxValue < this._value)
					{
						ThrowInvalidTypeAs<Int16>(this);
					}
					
					return (Int16)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int16)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int16)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int16>(this);
				return default(Int16); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt16" /> instance.
		/// </summary>
		/// <returns><see cref="UInt16" /> instance corresponds to this instance.</returns>
		[CLSCompliant(false)]
		public UInt16 AsUInt16()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<UInt16>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt16>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				const ulong maxValue = unchecked((ulong)UInt16.MaxValue);
				
				if (maxValue < this._value)
				{
					// Overflow or negative.
					ThrowInvalidTypeAs<UInt16>(this);
				}

				return unchecked((UInt16 )this._value);
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt16)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt16)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt16>(this);
				return default(UInt16); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int32" /> instance.
		/// </summary>
		/// <returns><see cref="Int32" /> instance corresponds to this instance.</returns>
		public Int32 AsInt32()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Int32>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int32>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Int32.MinValue;
					const long maxValue = (long)Int32.MaxValue;
					
					long asInt64 = unchecked((long)this._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Int32>(this);
					}

					return unchecked((Int32)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int32.MaxValue);
					if(maxValue < this._value)
					{
						ThrowInvalidTypeAs<Int32>(this);
					}
					
					return (Int32)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int32)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int32)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int32>(this);
				return default(Int32); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt32" /> instance.
		/// </summary>
		/// <returns><see cref="UInt32" /> instance corresponds to this instance.</returns>
		[CLSCompliant(false)]
		public UInt32 AsUInt32()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<UInt32>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt32>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				const ulong maxValue = unchecked((ulong)UInt32.MaxValue);
				
				if (maxValue < this._value)
				{
					// Overflow or negative.
					ThrowInvalidTypeAs<UInt32>(this);
				}

				return unchecked((UInt32 )this._value);
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt32)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt32)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt32>(this);
				return default(UInt32); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int64" /> instance.
		/// </summary>
		/// <returns><see cref="Int64" /> instance corresponds to this instance.</returns>
		public Int64 AsInt64()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Int64>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int64>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return unchecked((long)this._value);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int64.MaxValue);
					if(maxValue < this._value)
					{
						ThrowInvalidTypeAs<Int64>(this);
					}
					
					return (Int64)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int64)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int64)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int64>(this);
				return default(Int64); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt64" /> instance.
		/// </summary>
		/// <returns><see cref="UInt64" /> instance corresponds to this instance.</returns>
		[CLSCompliant(false)]
		public UInt64 AsUInt64()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<UInt64>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt64>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					if (Int64.MaxValue < this._value)
					{
						// Negative.
						ThrowInvalidTypeAs<UInt64>(this);
					}
				}

				return this._value;
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt64)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt64)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt64>(this);
				return default(UInt64); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Single" /> instance.
		/// </summary>
		/// <returns><see cref="Single" /> instance corresponds to this instance.</returns>
		public Single AsSingle()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Single>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<float>(this);
			}
			
			Debug.Assert(typeCode != null);

			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (float)(unchecked((long)this._value));
				}
				else
				{
					return (float)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Single)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Single)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<float>(this);
				return default(float); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Double" /> instance.
		/// </summary>
		/// <returns><see cref="Double" /> instance corresponds to this instance.</returns>
		public Double AsDouble()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<Double>();
			}
			var typeCode = this._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<double>(this);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (double)(unchecked((long)this._value));
				}
				else
				{
					return (double)this._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Double)BitConverter.Int64BitsToDouble(unchecked((long)this._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Double)Binary.FromBits(unchecked((int)this._value));
			}
			else
			{
				ThrowInvalidTypeAs<double>(this);
				return default(double); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="String" /> instance.
		/// </summary>
		/// <returns><see cref="String" /> instance corresponds to this instance.</returns>
		public String? AsString()
		{
			VerifyUnderlyingRawType<string>(this, null);

			if(this._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = this._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetString();
		}

		/// <summary>
		///		Convert this instance to <see cref="Byte" />[] instance.
		/// </summary>
		/// <returns><see cref="Byte" />[] instance corresponds to this instance.</returns>
		public Byte[]? AsBinary()
		{
			VerifyUnderlyingRawType<byte[]>(this, null);

			if(this._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = this._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteArray();
		}

		/// <summary>
		///		Convert this instance to <see cref="ReadOnlyMemory<byte>" /> instance.
		/// </summary>
		/// <returns><see cref="ReadOnlyMemory<byte>" /> instance corresponds to this instance.</returns>
		public ReadOnlyMemory<byte> AsReadOnlyMemoryOfByte()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<ReadOnlyMemory<byte>>();
			}
			VerifyUnderlyingRawType<ReadOnlyMemory<byte>>(this, null);

			var asString = this._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteMemory();
		}

		/// <summary>
		///		Convert this instance to <see cref="ReadOnlyMemory<char>" /> instance.
		/// </summary>
		/// <returns><see cref="ReadOnlyMemory<char>" /> instance corresponds to this instance.</returns>
		public ReadOnlyMemory<char> AsReadOnlyMemoryOfChar()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<ReadOnlyMemory<char>>();
			}
			VerifyUnderlyingRawType<ReadOnlyMemory<char>>(this, null);

			var asString = this._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetCharMemory();
		}

#pragma warning disable 0618 // obsolete

		/// <summary>
		///		Convert this instance to <see cref="MessagePackExtendedTypeObject" /> instance.
		/// </summary>
		/// <returns><see cref="MessagePackExtendedTypeObject" /> instance corresponds to this instance.</returns>
		public MessagePackExtendedTypeObject AsMessagePackExtendedTypeObject()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<MessagePackExtendedTypeObject>();
			}
			VerifyUnderlyingType<MessagePackExtendedTypeObject>(this, null);

			return MessagePackExtendedTypeObject.Unpack(unchecked((byte)this._value), (this._handleOrTypeCode as byte[])!);
		}

#pragma warning restore 0618 // obsolete

		/// <summary>
		///		Convert this instance to <see cref="ExtensionTypeObject" /> instance.
		/// </summary>
		/// <returns><see cref="ExtensionTypeObject" /> instance corresponds to this instance.</returns>
		public ExtensionTypeObject AsExtensionTypeObject()
		{
			if(this.IsNil)
			{
				ThrowCannotBeNilAs<ExtensionTypeObject>();
			}
			VerifyUnderlyingType<ExtensionTypeObject>(this, null);
			Debug.Assert(this._handleOrTypeCode != null);

			return new ExtensionTypeObject(new ExtensionType(unchecked((long)this._value)), (ReadOnlySequence<byte>)this._handleOrTypeCode);
		}

		#endregion -- Primitive Type Conversion Methods --

		#region -- Conversion Operator Overloads --


		/// <summary>
		///		Convert <see cref="Boolean" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Boolean" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Boolean value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Byte" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Byte" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Byte value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="SByte" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="SByte" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static implicit operator MessagePackObject(SByte value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Int16" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Int16" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Int16 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="UInt16" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="UInt16" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static implicit operator MessagePackObject(UInt16 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Int32" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Int32" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Int32 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="UInt32" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="UInt32" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static implicit operator MessagePackObject(UInt32 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Int64" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Int64" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Int64 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="UInt64" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="UInt64" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static implicit operator MessagePackObject(UInt64 value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Single" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Single" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Single value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Double" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Double" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Double value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="String" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="String" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(String value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="Byte" />[]instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="Byte" />[] instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(Byte[] value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="ReadOnlyMemory<byte>" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="ReadOnlyMemory<byte>" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(ReadOnlyMemory<byte> value)
			=> new MessagePackObject(value);

		/// <summary>
		///		Convert <see cref="ReadOnlyMemory<char>" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="ReadOnlyMemory<char>" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(ReadOnlyMemory<char> value)
			=> new MessagePackObject(value);

#pragma warning disable 0618 // obsolete

		/// <summary>
		///		Convert <see cref="MessagePackExtendedTypeObject" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackExtendedTypeObject" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(MessagePackExtendedTypeObject value)
			=> new MessagePackObject(value);

#pragma warning restore 0618 // obsolete

		/// <summary>
		///		Convert <see cref="ExtensionTypeObject" />instance to <see cref="MessagePackObject"/> instance.
		/// </summary>
		/// <param name="value"><see cref="ExtensionTypeObject" /> instance.</param>
		/// <returns><see cref="MessagePackObject"/> instance corresponds to <paramref name="value"/>.</returns>
		public static implicit operator MessagePackObject(ExtensionTypeObject value)
			=> new MessagePackObject(value);


		/// <summary>
		///		Convert this instance to <see cref="Boolean" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Boolean" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Boolean(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Boolean>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null || typeCode.TypeCode != MessagePackValueTypeCode.Boolean)
			{
				ThrowInvalidTypeAs<bool>(value);
			}

			Debug.Assert(typeCode != null);
			
			return value._value != 0;
		}

		/// <summary>
		///		Convert this instance to <see cref="Byte" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Byte" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Byte(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Byte>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Byte>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Byte.MinValue;
					const long maxValue = (long)Byte.MaxValue;
					
					long asInt64 = unchecked((long)value._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Byte>(value);
					}

					return unchecked((Byte)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Byte.MaxValue);
					if(maxValue < value._value)
					{
						ThrowInvalidTypeAs<Byte>(value);
					}
					
					return (Byte)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Byte)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Byte)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<Byte>(value);
				return default(Byte); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="SByte" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="SByte" /> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static explicit operator SByte(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<SByte>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<SByte>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)SByte.MinValue;
					const long maxValue = (long)SByte.MaxValue;
					
					long asInt64 = unchecked((long)value._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<SByte>(value);
					}

					return unchecked((SByte)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)SByte.MaxValue);
					if(maxValue < value._value)
					{
						ThrowInvalidTypeAs<SByte>(value);
					}
					
					return (SByte)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (SByte)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (SByte)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<SByte>(value);
				return default(SByte); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int16" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Int16" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Int16(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Int16>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int16>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Int16.MinValue;
					const long maxValue = (long)Int16.MaxValue;
					
					long asInt64 = unchecked((long)value._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Int16>(value);
					}

					return unchecked((Int16)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int16.MaxValue);
					if(maxValue < value._value)
					{
						ThrowInvalidTypeAs<Int16>(value);
					}
					
					return (Int16)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int16)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int16)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int16>(value);
				return default(Int16); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt16" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="UInt16" /> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static explicit operator UInt16(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<UInt16>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt16>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				const ulong maxValue = unchecked((ulong)UInt16.MaxValue);
				
				if (maxValue < value._value)
				{
					// Overflow or negative.
					ThrowInvalidTypeAs<UInt16>(value);
				}

				return unchecked((UInt16 )value._value);
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt16)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt16)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt16>(value);
				return default(UInt16); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int32" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Int32" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Int32(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Int32>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int32>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					const long minValue = (long)Int32.MinValue;
					const long maxValue = (long)Int32.MaxValue;
					
					long asInt64 = unchecked((long)value._value);
					if(asInt64 < minValue || maxValue < asInt64)
					{
						ThrowInvalidTypeAs<Int32>(value);
					}

					return unchecked((Int32)asInt64);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int32.MaxValue);
					if(maxValue < value._value)
					{
						ThrowInvalidTypeAs<Int32>(value);
					}
					
					return (Int32)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int32)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int32)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int32>(value);
				return default(Int32); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt32" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="UInt32" /> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static explicit operator UInt32(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<UInt32>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt32>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				const ulong maxValue = unchecked((ulong)UInt32.MaxValue);
				
				if (maxValue < value._value)
				{
					// Overflow or negative.
					ThrowInvalidTypeAs<UInt32>(value);
				}

				return unchecked((UInt32 )value._value);
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt32)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt32)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt32>(value);
				return default(UInt32); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Int64" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Int64" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Int64(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Int64>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<Int64>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return unchecked((long)value._value);
				}
				else
				{
					const ulong maxValue = unchecked((ulong)Int64.MaxValue);
					if(maxValue < value._value)
					{
						ThrowInvalidTypeAs<Int64>(value);
					}
					
					return (Int64)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Int64)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Int64)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<Int64>(value);
				return default(Int64); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="UInt64" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="UInt64" /> instance corresponds to <paramref name="value"/>.</returns>
		[CLSCompliant(false)]
		public static explicit operator UInt64(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<UInt64>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<UInt64>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					if (Int64.MaxValue < value._value)
					{
						// Negative.
						ThrowInvalidTypeAs<UInt64>(value);
					}
				}

				return value._value;
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (UInt64)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (UInt64)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<UInt64>(value);
				return default(UInt64); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Single" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Single" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Single(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Single>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<float>(value);
			}
			
			Debug.Assert(typeCode != null);

			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (float)(unchecked((long)value._value));
				}
				else
				{
					return (float)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Single)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Single)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<float>(value);
				return default(float); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="Double" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Double" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Double(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<Double>();
			}
			var typeCode = value._handleOrTypeCode as ValueTypeCode;
			if (typeCode == null)
			{
				ThrowInvalidTypeAs<double>(value);
			}

			Debug.Assert(typeCode != null);
			
			if (typeCode.IsInteger)
			{
				if (typeCode.IsSigned)
				{
					return (double)(unchecked((long)value._value));
				}
				else
				{
					return (double)value._value;
				}
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Double)
			{
				return (Double)BitConverter.Int64BitsToDouble(unchecked((long)value._value));
			}
			else if (typeCode.TypeCode == MessagePackValueTypeCode.Single)
			{
				return (Double)Binary.FromBits(unchecked((int)value._value));
			}
			else
			{
				ThrowInvalidTypeAs<double>(value);
				return default(double); // Never reaches
			}
		}

		/// <summary>
		///		Convert this instance to <see cref="String" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="String" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator String?(MessagePackObject value)
		{
			VerifyUnderlyingRawType<string>(value, "value");

			if(value._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = value._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetString();
		}

		/// <summary>
		///		Convert this instance to <see cref="Byte" />[] instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="Byte" />[] instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator Byte[]?(MessagePackObject value)
		{
			VerifyUnderlyingRawType<byte[]>(value, "value");

			if(value._handleOrTypeCode == null)
			{
				// nil
				return null;
			}

			var asString = value._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteArray();
		}

		/// <summary>
		///		Convert this instance to <see cref="ReadOnlyMemory<byte>" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="ReadOnlyMemory<byte>" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator ReadOnlyMemory<byte>(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<ReadOnlyMemory<byte>>();
			}
			VerifyUnderlyingRawType<ReadOnlyMemory<byte>>(value, "value");

			var asString = value._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetByteMemory();
		}

		/// <summary>
		///		Convert this instance to <see cref="ReadOnlyMemory<char>" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="ReadOnlyMemory<char>" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator ReadOnlyMemory<char>(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<ReadOnlyMemory<char>>();
			}
			VerifyUnderlyingRawType<ReadOnlyMemory<char>>(value, "value");

			var asString = value._handleOrTypeCode as MessagePackString;
			Debug.Assert(asString != null);
			return asString.GetCharMemory();
		}

#pragma warning disable 0618 // obsolete

		/// <summary>
		///		Convert this instance to <see cref="MessagePackExtendedTypeObject" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="MessagePackExtendedTypeObject" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator MessagePackExtendedTypeObject(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<MessagePackExtendedTypeObject>();
			}
			VerifyUnderlyingType<MessagePackExtendedTypeObject>(value, "value");

			return MessagePackExtendedTypeObject.Unpack(unchecked((byte)value._value), (value._handleOrTypeCode as byte[])!);
		}

#pragma warning restore 0618 // obsolete

		/// <summary>
		///		Convert this instance to <see cref="ExtensionTypeObject" /> instance.
		/// </summary>
		/// <param name="value"><see cref="MessagePackObject"/> instance.</param>
		/// <returns><see cref="ExtensionTypeObject" /> instance corresponds to <paramref name="value"/>.</returns>
		public static explicit operator ExtensionTypeObject(MessagePackObject value)
		{
			if(value.IsNil)
			{
				ThrowCannotBeNilAs<ExtensionTypeObject>();
			}
			VerifyUnderlyingType<ExtensionTypeObject>(value, "value");
			Debug.Assert(value._handleOrTypeCode != null);

			return new ExtensionTypeObject(new ExtensionType(unchecked((long)value._value)), (ReadOnlySequence<byte>)value._handleOrTypeCode);
		}

		#endregion -- Conversion Operator Overloads --
	}
}
